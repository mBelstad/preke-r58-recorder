<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Graphics App - R58 Mixer</title>
    
    <!-- Reveal.js CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.6.1/dist/reveal.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.6.1/dist/theme/black.css" id="theme">
    
    <!-- KaTeX for Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    
    <!-- Quill CSS -->
    <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">

    <!-- Reveal.js Plugins -->
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.6.1/plugin/markdown/markdown.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.6.1/plugin/notes/notes.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.6.1/plugin/highlight/highlight.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.6.1/plugin/zoom/zoom.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.6.1/plugin/search/search.js"></script>
    
    <!-- Additional Reveal.js Plugins (conditionally loaded if available) -->
    <script src="https://cdn.jsdelivr.net/npm/reveal.js-appearance@1.1.1/plugin/appearance/appearance.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js-chalkboard@2.3.0/plugin/chalkboard/plugin.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js-menu@2.1.0/plugin/menu/menu.js"></script>

    <!-- Quill JS -->
    <script src="https://cdn.quilljs.com/1.3.6/quill.min.js"></script>
    
    <!-- Reveal.js Core -->
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.6.1/dist/reveal.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0a0a;
            --bg-secondary: #111111;
            --bg-tertiary: #1a1a1a;
            --bg-hover: #222222;
            --border-color: rgba(255, 255, 255, 0.1);
            --text-primary: #ffffff;
            --text-secondary: #a0a0a0;
            --accent-blue: #3b82f6;
            --accent-blue-hover: #2563eb;
            --accent-green: #10b981;
            --accent-red: #ef4444;
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3);
            --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.4);
            --shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.5);
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Inter', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Header */
        .header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            padding: 16px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 1000;
            box-shadow: var(--shadow-sm);
        }

        .header h1 {
            font-size: 20px;
            font-weight: 700;
            background: linear-gradient(135deg, #ffffff 0%, #a0a0a0 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header-actions {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        /* Main Container */
        .main-container {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 450px;
            gap: 0;
            overflow: hidden;
        }

        /* Presentation Area */
        .presentation-area {
            background: #000;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .reveal-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .reveal {
            width: 100%;
            height: 100%;
        }

        /* Control Panel */
        .control-panel {
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .panel-section {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            padding: 16px;
            box-shadow: var(--shadow-sm);
        }

        .panel-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border-color);
        }

        /* Forms */
        .form-group {
            margin-bottom: 16px;
        }

        .form-group:last-child {
            margin-bottom: 0;
        }

        .form-label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .form-input,
        .form-select,
        .form-textarea {
            width: 100%;
            padding: 10px 12px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            color: var(--text-primary);
            font-size: 13px;
            font-family: inherit;
            transition: all 0.2s ease;
        }

        .form-input:focus,
        .form-select:focus,
        .form-textarea:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
        }

        .form-textarea {
            min-height: 100px;
            resize: vertical;
        }

        .form-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .form-checkbox input[type="checkbox"] {
            accent-color: var(--accent-blue);
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        /* Buttons */
        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: var(--radius-sm);
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent-blue) 0%, var(--accent-blue-hover) 100%);
            color: white;
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.4);
        }

        .btn-secondary {
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover {
            background: var(--bg-hover);
            border-color: var(--accent-blue);
        }

        .btn-danger {
            background: rgba(239, 68, 68, 0.1);
            color: var(--accent-red);
            border: 1px solid rgba(239, 68, 68, 0.2);
        }

        .btn-danger:hover {
            background: rgba(239, 68, 68, 0.2);
            border-color: var(--accent-red);
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
        }

        /* Slide Controls */
        .slide-controls {
            display: grid;
            grid-template-columns: 40px 1fr 40px;
            gap: 8px;
            align-items: center;
            margin-bottom: 12px;
        }

        .slide-indicator {
            text-align: center;
            background: var(--bg-primary);
            padding: 10px;
            border-radius: var(--radius-sm);
            border: 1px solid var(--border-color);
            font-family: monospace;
            font-size: 14px;
        }

        /* Advanced Sections */
        .advanced-toggle {
            background: none;
            border: none;
            color: var(--accent-blue);
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 0;
            margin-top: 12px;
        }

        .advanced-toggle:hover {
            text-decoration: underline;
        }

        .advanced-section {
            display: none;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border-color);
        }

        .advanced-section.expanded {
            display: block;
            animation: slideDown 0.2s ease;
        }

        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Quill Editor Overrides */
        #quillEditor {
            background: white;
            border-radius: var(--radius-sm);
            color: #333;
            min-height: 200px;
        }
        
        .ql-toolbar {
            border-top-left-radius: var(--radius-sm);
            border-top-right-radius: var(--radius-sm);
            background: #f3f4f6;
            border-color: #e5e7eb !important;
        }
        
        .ql-container {
            border-bottom-left-radius: var(--radius-sm);
            border-bottom-right-radius: var(--radius-sm);
            border-color: #e5e7eb !important;
            font-size: 14px;
        }

        /* Lists */
        .item-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: 250px;
            overflow-y: auto;
        }

        .list-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .list-item:hover {
            border-color: var(--accent-blue);
            background: rgba(59, 130, 246, 0.05);
        }

        .list-item.active {
            border-color: var(--accent-blue);
            background: rgba(59, 130, 246, 0.1);
        }

        .list-item-thumbnail {
            width: 40px;
            height: 40px;
            border-radius: 4px;
            object-fit: cover;
            background: #333;
        }

        .list-item-content {
            flex: 1;
            overflow: hidden;
        }

        .list-item-title {
            font-size: 13px;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .list-item-subtitle {
            font-size: 11px;
            color: var(--text-secondary);
        }

        /* Color Picker & Inputs */
        .color-input-group {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        input[type="color"] {
            -webkit-appearance: none;
            border: none;
            width: 40px;
            height: 40px;
            cursor: pointer;
            background: none;
            padding: 0;
        }

        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        input[type="color"]::-webkit-color-swatch {
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
        }

        .color-preview {
            width: 40px;
            height: 40px;
            border-radius: var(--radius-sm);
            border: 1px solid var(--border-color);
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--bg-hover);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #333;
        }

        /* Notification */
        .notification {
            position: fixed;
            top: 24px;
            right: 24px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            padding: 16px 20px;
            box-shadow: var(--shadow-lg);
            z-index: 10000;
            display: flex;
            align-items: center;
            gap: 12px;
            min-width: 300px;
            animation: slideIn 0.3s ease;
            color: var(--text-primary);
        }

        .notification.error {
            border-left: 4px solid var(--accent-red);
        }

        .notification:not(.error) {
            border-left: 4px solid var(--accent-green);
        }

        .hidden {
            display: none;
        }
        
        .empty-state {
            padding: 20px;
            text-align: center;
            color: var(--text-secondary);
            font-size: 13px;
        }
        
        .empty-state-icon {
            font-size: 24px;
            margin-bottom: 8px;
            opacity: 0.5;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üé® Graphics App</h1>
        <div class="header-actions">
            <select id="presentationSelect" class="form-select" style="width: 200px;">
                <option value="">New Presentation...</option>
            </select>
            <button class="btn btn-primary" id="saveBtn" title="Save (Ctrl+S)">
                <span>üíæ</span> Save
            </button>
            <button class="btn btn-secondary" id="exportBtn" title="Export to Mixer">
                <span>üì§</span> Export
            </button>
            <button class="btn btn-secondary" id="fullscreenBtn" title="Fullscreen (F11)">
                <span>‚õ∂</span>
            </button>
            <button class="btn btn-secondary" onclick="window.location.href='/switcher'">
                <span>‚Üê</span> Back
            </button>
        </div>
    </div>

    <div class="main-container">
        <div class="presentation-area">
            <div class="reveal-container">
                <div class="reveal" id="reveal">
                    <div class="slides" id="slides">
                        <section data-markdown>
                            <script type="text/template">
# Welcome

Create your presentation using Markdown or HTML
                            </script>
                        </section>
                    </div>
                </div>
            </div>
        </div>

        <div class="control-panel">
            <!-- Presentation Settings -->
            <div class="panel-section">
                <div class="panel-title">
                    <span>üìÑ Presentation</span>
                </div>
                <div class="form-group">
                    <label class="form-label">Name</label>
                    <input type="text" id="presentationName" class="form-input" placeholder="My Presentation">
                </div>
                <div class="form-group">
                    <label class="form-label">ID</label>
                    <input type="text" id="presentationId" class="form-input" placeholder="my_presentation">
                </div>
                <div class="form-group">
                    <label class="form-label">Theme</label>
                    <select id="themeSelect" class="form-select">
                        <option value="black">Black</option>
                        <option value="white">White</option>
                        <option value="league">League</option>
                        <option value="beige">Beige</option>
                        <option value="sky">Sky</option>
                        <option value="night">Night</option>
                        <option value="serif">Serif</option>
                        <option value="simple">Simple</option>
                        <option value="solarized">Solarized</option>
                    </select>
                </div>
                <button class="advanced-toggle" onclick="toggleAdvanced('presAdvanced')">
                    <span>‚öôÔ∏è Advanced Settings</span>
                    <span id="presAdvancedIcon">‚ñº</span>
                </button>
                <div class="advanced-section" id="presAdvanced">
                    <div class="form-group">
                        <label class="form-label">Global Transition</label>
                        <select id="globalTransition" class="form-select">
                            <option value="slide">Slide</option>
                            <option value="fade">Fade</option>
                            <option value="none">None</option>
                            <option value="zoom">Zoom</option>
                            <option value="convex">Convex</option>
                            <option value="concave">Concave</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Transition Speed</label>
                        <select id="transitionSpeed" class="form-select">
                            <option value="default">Default</option>
                            <option value="fast">Fast</option>
                            <option value="slow">Slow</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <div class="form-checkbox">
                            <input type="checkbox" id="enableControls" checked>
                            <label>Show Controls</label>
                        </div>
                    </div>
                    <div class="form-group">
                        <div class="form-checkbox">
                            <input type="checkbox" id="enableProgress" checked>
                            <label>Show Progress</label>
                        </div>
                    </div>
                    <div class="form-group">
                        <div class="form-checkbox">
                            <input type="checkbox" id="enableFragments" checked>
                            <label>Enable Fragments</label>
                        </div>
                    </div>
                    <div class="form-group">
                        <div class="form-checkbox">
                            <input type="checkbox" id="enableAutoAnimate">
                            <label>Auto-Animate</label>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Auto-Slide (seconds, 0 = disabled)</label>
                        <input type="number" id="autoSlide" class="form-input" value="0" min="0" step="1">
                    </div>
                </div>
            </div>

            <!-- Slide Navigation -->
            <div class="panel-section">
                <div class="panel-title">
                    <span>üéØ Navigation</span>
                </div>
                <div class="slide-controls">
                    <button class="btn btn-secondary" id="prevBtn">‚óÄ</button>
                    <div class="slide-indicator" id="slideIndicator">1 / 1</div>
                    <button class="btn btn-secondary" id="nextBtn">‚ñ∂</button>
                </div>
                <div style="display: flex; gap: 8px;">
                    <button class="btn btn-secondary btn-small" id="addSlideBtn" style="flex: 1;">‚ûï Add Slide</button>
                    <button class="btn btn-secondary btn-small" id="addVerticalSlideBtn" style="flex: 1;">‚¨á Vertical</button>
                    <button class="btn btn-danger btn-small" id="removeSlideBtn" style="flex: 1;">üóëÔ∏è Remove</button>
                </div>
            </div>

            <!-- Slide Style -->
            <div class="panel-section">
                <div class="panel-title">
                    <span>üé® Slide Style</span>
                </div>
                <div class="form-group">
                    <label class="form-label">Background Color</label>
                    <div class="color-input-group">
                        <input type="color" id="slideBgColor">
                        <div style="flex: 1; display: flex; align-items: center; gap: 8px;">
                            <input type="number" id="slideBgColorOpacity" class="form-input" value="100" min="0" max="100" style="width: 70px;">
                            <span style="font-size: 12px; color: var(--text-secondary);">% Opacity</span>
                        </div>
                        <div class="color-preview" id="bgColorPreview" style="background: #000;"></div>
                    </div>
                </div>
                <button class="advanced-toggle" onclick="toggleAdvanced('slideAdvanced')">
                    <span>‚öôÔ∏è Advanced Background</span>
                    <span id="slideAdvancedIcon">‚ñº</span>
                </button>
                <div class="advanced-section" id="slideAdvanced">
                    <div class="form-group">
                        <label class="form-label">Transition</label>
                        <select id="slideTransition" class="form-select">
                            <option value="">Use Global</option>
                            <option value="slide">Slide</option>
                            <option value="fade">Fade</option>
                            <option value="none">None</option>
                            <option value="zoom">Zoom</option>
                            <option value="convex">Convex</option>
                            <option value="concave">Concave</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Background Image URL</label>
                        <div style="display: flex; gap: 8px;">
                            <input type="text" id="slideBgImage" class="form-input" placeholder="https://...">
                            <input type="file" id="uploadImageBtn" accept="image/*" class="hidden">
                            <button class="btn btn-secondary btn-small" onclick="document.getElementById('uploadImageBtn').click()">Upload</button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Background Video URL</label>
                        <div style="display: flex; gap: 8px;">
                            <input type="text" id="slideBgVideo" class="form-input" placeholder="https://...">
                            <input type="file" id="uploadVideoBtn" accept="video/*" class="hidden">
                            <button class="btn btn-secondary btn-small" onclick="document.getElementById('uploadVideoBtn').click()">Upload</button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Background Size</label>
                        <select id="slideBgSize" class="form-select">
                            <option value="">Default</option>
                            <option value="cover">Cover</option>
                            <option value="contain">Contain</option>
                            <option value="auto">Auto</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <div class="form-checkbox">
                            <input type="checkbox" id="slideAutoAnimate">
                            <label>Auto-Animate This Slide</label>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Duration (s)</label>
                        <input type="number" id="slideAutoAnimateDuration" class="form-input" value="1.0" step="0.1">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Easing</label>
                        <select id="slideAutoAnimateEasing" class="form-select">
                            <option value="ease">Ease</option>
                            <option value="linear">Linear</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- Templates -->
            <div class="panel-section">
                <div class="panel-title">
                    <span>üìã Templates</span>
                </div>
                <div style="display: flex; gap: 8px;">
                    <select id="templateSelect" class="form-select">
                        <option value="">Choose template...</option>
                        <option value="title">Title Slide</option>
                        <option value="content">Content Slide</option>
                        <option value="two-column">Two Column</option>
                        <option value="image-left">Image Left</option>
                        <option value="image-right">Image Right</option>
                        <option value="quote">Quote</option>
                        <option value="code">Code</option>
                    </select>
                    <button class="btn btn-primary btn-small" id="applyTemplateBtn">Apply</button>
                </div>
            </div>

            <!-- Content Editor -->
            <div class="panel-section">
                <div class="panel-title">
                    <span>‚úèÔ∏è Content</span>
                    <button class="btn btn-secondary btn-small" id="toggleEditorMode">üìù Mode</button>
                </div>
                <div class="form-group">
                    <div id="quillEditor"></div>
                    <textarea id="slideContent" class="form-textarea" placeholder="# Slide Title&#10;&#10;Content..." style="display: none; height: 200px; font-family: monospace;"></textarea>
                </div>
                <button class="btn btn-primary" id="updateSlideBtn" style="width: 100%;">
                    üíæ Update Slide
                </button>
                
                <button class="advanced-toggle" onclick="toggleAdvanced('notesAdvanced')">
                    <span>üìù Speaker Notes</span>
                    <span id="notesAdvancedIcon">‚ñº</span>
                </button>
                <div class="advanced-section" id="notesAdvanced">
                    <textarea id="slideNotes" class="form-textarea" placeholder="Notes..." style="height: 100px;"></textarea>
                </div>
            </div>

            <!-- Media Library -->
            <div class="panel-section">
                <div class="panel-title">
                    <span>üñºÔ∏è Media</span>
                    <div style="display: flex; gap: 4px;">
                        <input type="file" id="addImageFile" accept="image/*" class="hidden" multiple>
                        <button class="btn btn-secondary btn-small" onclick="document.getElementById('addImageFile').click()">‚ûï Upload</button>
                        <button class="btn btn-secondary btn-small" id="browseMediaBtn">üìÇ Browse</button>
                        <button class="btn btn-secondary btn-small" id="refreshMediaBtn">üîÑ</button>
                    </div>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Images on Slide</label>
                    <div id="imageList" class="item-list"></div>
                </div>
                
                <div class="form-group">
                    <input type="file" id="addImageBtn" accept="image/*" class="hidden">
                    <button class="btn btn-secondary btn-small" style="width: 100%;" onclick="document.getElementById('addImageBtn').click()">
                        Add Image to Slide
                    </button>
                </div>

                <div id="imageEditor" class="advanced-section">
                    <div class="form-group">
                        <label class="form-label">Image URL</label>
                        <input type="text" id="imageUrl" class="form-input">
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <div class="form-group">
                            <label class="form-label">X (%)</label>
                            <input type="number" id="imageX" class="form-input">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Y (%)</label>
                            <input type="number" id="imageY" class="form-input">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Width (%)</label>
                            <input type="number" id="imageWidth" class="form-input">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Height (%)</label>
                            <input type="number" id="imageHeight" class="form-input">
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Opacity</label>
                        <input type="range" id="imageOpacity" min="0" max="100">
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Cropping</label>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                            <input type="number" id="imageCropX" class="form-input" placeholder="Left %">
                            <input type="number" id="imageCropY" class="form-input" placeholder="Top %">
                            <input type="number" id="imageCropWidth" class="form-input" placeholder="Width %">
                            <input type="number" id="imageCropHeight" class="form-input" placeholder="Height %">
                        </div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <div class="form-group">
                            <label class="form-label">Radius</label>
                            <input type="number" id="imageBorderRadius" class="form-input">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Fit</label>
                            <select id="imageObjectFit" class="form-select">
                                <option value="contain">Contain</option>
                                <option value="cover">Cover</option>
                                <option value="fill">Fill</option>
                            </select>
                        </div>
                    </div>
                    
                    <div style="display: flex; gap: 8px; margin-top: 8px;">
                        <button class="btn btn-primary btn-small" id="updateImageBtn" style="flex: 1;">Update</button>
                        <button class="btn btn-danger btn-small" id="removeImageBtn" style="flex: 1;">Remove</button>
                    </div>
                </div>
            </div>

            <!-- Shapes -->
            <div class="panel-section">
                <div class="panel-title">
                    <span>üî∑ Shapes</span>
                </div>
                
                <div class="form-group" style="display: flex; gap: 8px;">
                    <select id="shapeType" class="form-select">
                        <option value="rectangle">Rectangle</option>
                        <option value="circle">Circle</option>
                        <option value="triangle">Triangle</option>
                        <option value="ellipse">Ellipse</option>
                    </select>
                    <button class="btn btn-primary btn-small" id="addShapeBtn">Add</button>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Shapes on Slide</label>
                    <div id="shapeList" class="item-list"></div>
                </div>

                <div id="shapeEditor" class="advanced-section">
                    <!-- Hidden inputs for script compatibility -->
                    <input type="hidden" id="shapeTypeDisplay">
                    <input type="hidden" id="shapeImageUrl">
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <div class="form-group">
                            <label class="form-label">X (%)</label>
                            <input type="number" id="shapeX" class="form-input">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Y (%)</label>
                            <input type="number" id="shapeY" class="form-input">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Width (%)</label>
                            <input type="number" id="shapeWidth" class="form-input">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Height (%)</label>
                            <input type="number" id="shapeHeight" class="form-input">
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Fill Type</label>
                        <select id="shapeFillType" class="form-select">
                            <option value="color">Color</option>
                            <option value="gradient">Gradient</option>
                            <option value="image">Image</option>
                        </select>
                    </div>
                    
                    <div id="shapeFillColor">
                        <div class="form-group">
                            <label class="form-label">Color</label>
                            <div class="color-input-group">
                                <input type="color" id="shapeColor">
                                <input type="number" id="shapeColorOpacity" class="form-input" placeholder="Opacity %" min="0" max="100">
                            </div>
                        </div>
                    </div>
                    
                    <div id="shapeFillGradient" class="hidden">
                        <div class="form-group">
                            <label class="form-label">Type</label>
                            <select id="shapeGradientType" class="form-select">
                                <option value="linear">Linear</option>
                                <option value="radial">Radial</option>
                                <option value="conic">Conic</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label class="form-label">Direction</label>
                            <input type="text" id="shapeGradientDirection" class="form-input" placeholder="to right">
                        </div>
                        <div id="gradientColorStops"></div>
                        <!-- Hidden inputs for script logic that manipulates these IDs directly -->
                        <div class="hidden">
                            <input id="shapeGradientColor1">
                            <input id="shapeGradientStop1">
                            <input id="shapeGradientColor2">
                            <input id="shapeGradientStop2">
                        </div>
                        <button class="btn btn-secondary btn-small" id="addGradientColorBtn" style="width: 100%; margin-top: 8px;">Add Stop</button>
                    </div>
                    
                    <div id="shapeFillImage" class="hidden">
                        <div class="form-group">
                            <input type="file" id="uploadShapeImageBtn" accept="image/*" class="hidden">
                            <button class="btn btn-secondary btn-small" style="width: 100%;" onclick="document.getElementById('uploadShapeImageBtn').click()">
                                Upload Image
                            </button>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Border</label>
                        <div style="display: flex; gap: 8px;">
                            <input type="number" id="shapeBorderWidth" class="form-input" placeholder="Width">
                            <input type="color" id="shapeBorderColor">
                        </div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <div class="form-group">
                            <label class="form-label">Border Opacity</label>
                            <input type="number" id="shapeBorderOpacity" class="form-input">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Radius</label>
                            <input type="number" id="shapeBorderRadius" class="form-input">
                        </div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <div class="form-group">
                            <label class="form-label">Opacity</label>
                            <input type="number" id="shapeOpacity" class="form-input">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Rotation</label>
                            <input type="number" id="shapeRotation" class="form-input">
                        </div>
                    </div>
                    
                    <div style="display: flex; gap: 8px; margin-top: 8px;">
                        <button class="btn btn-primary btn-small" id="updateShapeBtn" style="flex: 1;">Update</button>
                        <button class="btn btn-danger btn-small" id="removeShapeBtn" style="flex: 1;">Remove</button>
                    </div>
                </div>
            </div>
            
            <!-- Presentation List (Hidden used for logic) -->
            <div id="presentationList" class="hidden"></div>
        </div>
    </div>

    <!-- Script Logic -->
    <script>
        const API_BASE = window.location.origin;
        let reveal = null;
        let quillEditor = null;
        let editorMode = 'visual'; // 'visual' or 'markdown'
        let currentPresentation = {
            id: '',
            name: '',
            theme: 'black',
            transition: 'slide',
            transitionSpeed: 'default',
            controls: true,
            progress: true,
            fragments: true,
            autoAnimate: false,
            autoSlide: 0,
            slides: []
        };
        let currentSlideIndex = 0;
        let currentVerticalIndex = 0;

        // Toggle collapsible sections
        function toggleSection(sectionId) {
            const content = document.getElementById(sectionId);
            // Check if previous element exists and has the toggle class
            const header = content.previousElementSibling;
            if (header) {
                const toggle = header.querySelector('.panel-toggle');
                content.classList.toggle('expanded');
                if (toggle) {
                    toggle.textContent = content.classList.contains('expanded') ? '‚ñº' : '‚ñ∂';
                }
            }
        }

        function toggleAdvanced(sectionId) {
            const section = document.getElementById(sectionId);
            const icon = document.getElementById(sectionId + 'Icon');
            section.classList.toggle('expanded');
            if (icon) {
                icon.textContent = section.classList.contains('expanded') ? '‚ñ≤' : '‚ñº';
            }
        }

        // Initialize Quill Editor
        function initQuillEditor() {
            if (typeof Quill === 'undefined') {
                console.warn('Quill.js not loaded, falling back to textarea');
                document.getElementById('quillEditor').style.display = 'none';
                document.getElementById('slideContent').style.display = 'block';
                editorMode = 'markdown';
                return;
            }

            const quillEditorElement = document.getElementById('quillEditor');
            const textarea = document.getElementById('slideContent');
            
            // Configure Quill with useful modules
            quillEditor = new Quill('#quillEditor', {
                theme: 'snow',
                modules: {
                    toolbar: [
                        [{ 'header': [1, 2, 3, 4, 5, 6, false] }],
                        ['bold', 'italic', 'underline', 'strike'],
                        [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                        [{ 'script': 'sub'}, { 'script': 'super' }],
                        [{ 'indent': '-1'}, { 'indent': '+1' }],
                        [{ 'color': [] }, { 'background': [] }],
                        [{ 'align': [] }],
                        ['link', 'image', 'video'],
                        ['clean']
                    ]
                },
                placeholder: 'Start typing your slide content...'
            });

            // Sync Quill content to textarea on change
            quillEditor.on('text-change', function() {
                const html = quillEditor.root.innerHTML;
                textarea.value = htmlToMarkdown(html);
            });
            
            // Enable drag-and-drop for images in Quill editor
            const quillDropZone = quillEditor.container;
            quillDropZone.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.stopPropagation();
            });
            
            quillDropZone.addEventListener('drop', async function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                const files = Array.from(e.dataTransfer.files);
                for (const file of files) {
                    if (file.type.startsWith('image/')) {
                        // Upload image
                        const formData = new FormData();
                        formData.append('file', file);
                        
                        try {
                            const response = await fetch(`${API_BASE}/api/graphics/upload/image`, {
                                method: 'POST',
                                body: formData
                            });
                            
                            if (response.ok) {
                                const data = await response.json();
                                const imageUrl = `${API_BASE}${data.url}`;
                                
                                // Insert image into Quill editor at cursor position
                                const range = quillEditor.getSelection(true);
                                quillEditor.insertEmbed(range.index, 'image', imageUrl);
                                quillEditor.setSelection(range.index + 1);
                            }
                        } catch (error) {
                            console.error('Failed to upload dropped image:', error);
                        }
                    }
                }
            });

            // Set initial mode
            toggleEditorMode();
        }

        // Convert HTML to Markdown (simplified)
        function htmlToMarkdown(html) {
            if (!html || html === '<p><br></p>') return '';
            
            // Basic conversion - keep HTML for complex formatting
            let markdown = html
                .replace(/<h1>(.*?)<\/h1>/gi, '# $1\n\n')
                .replace(/<h2>(.*?)<\/h2>/gi, '## $1\n\n')
                .replace(/<h3>(.*?)<\/h3>/gi, '### $1\n\n')
                .replace(/<strong>(.*?)<\/strong>/gi, '**$1**')
                .replace(/<b>(.*?)<\/b>/gi, '**$1**')
                .replace(/<em>(.*?)<\/em>/gi, '*$1*')
                .replace(/<i>(.*?)<\/i>/gi, '*$1*')
                .replace(/<ul>(.*?)<\/ul>/gis, '$1')
                .replace(/<ol>(.*?)<\/ol>/gis, '$1')
                .replace(/<li>(.*?)<\/li>/gi, '- $1\n')
                .replace(/<p>(.*?)<\/p>/gi, '$1\n\n')
                .replace(/<br\s*\/?>/gi, '\n')
                .replace(/<a href="(.*?)">(.*?)<\/a>/gi, '[$2]($1)')
                .replace(/<img src="(.*?)" alt="(.*?)"\/?>/gi, '![$2]($1)')
                .trim();
            
            // If conversion resulted in mostly HTML tags, return original HTML
            if (markdown.includes('<') && markdown.includes('>')) {
                return html;
            }
            
            return markdown;
        }

        // Convert Markdown/HTML to Quill Delta
        function markdownToQuill(content) {
            if (!content) return '';
            
            // If content looks like HTML, use it directly
            if (content.includes('<') && content.includes('>')) {
                return content;
            }
            
            // Basic Markdown to HTML conversion
            let html = content
                .replace(/^# (.*$)/gim, '<h1>$1</h1>')
                .replace(/^## (.*$)/gim, '<h2>$1</h2>')
                .replace(/^### (.*$)/gim, '<h3>$1</h3>')
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                .replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2">$1</a>')
                .replace(/!\[(.*?)\]\((.*?)\)/g, '<img src="$2" alt="$1" />')
                .replace(/^- (.*$)/gim, '<li>$1</li>')
                .replace(/\n\n/g, '</p><p>')
                .replace(/\n/g, '<br>');
            
            if (!html.startsWith('<')) {
                html = '<p>' + html + '</p>';
            }
            
            return html;
        }

        // Toggle between visual and markdown editor
        function toggleEditorMode() {
            const quillEditorElement = document.getElementById('quillEditor');
            const textarea = document.getElementById('slideContent');
            const toggleBtn = document.getElementById('toggleEditorMode');
            
            if (editorMode === 'visual') {
                // Show Quill, hide textarea
                quillEditorElement.style.display = 'block';
                textarea.style.display = 'none';
                toggleBtn.textContent = 'üìù Markdown Mode';
                toggleBtn.title = 'Switch to Markdown Editor';
                
                // Sync textarea content to Quill
                if (quillEditor) {
                    const content = textarea.value || '';
                    const html = markdownToQuill(content);
                    quillEditor.root.innerHTML = html;
                }
            } else {
                // Show textarea, hide Quill
                quillEditorElement.style.display = 'none';
                textarea.style.display = 'block';
                toggleBtn.textContent = '‚ú® Visual Mode';
                toggleBtn.title = 'Switch to Visual Editor';
                
                // Sync Quill content to textarea
                if (quillEditor) {
                    const html = quillEditor.root.innerHTML;
                    textarea.value = htmlToMarkdown(html);
                }
            }
        }

        // Initialize Reveal.js
        function initReveal() {
            if (typeof Reveal === 'undefined') {
                console.error('Reveal.js is not loaded. Check CDN connection.');
                showNotification('Reveal.js failed to load. Check your internet connection.', 'error');
                return;
            }

            if (reveal) {
                try {
                    reveal.destroy();
                } catch (e) {
                    console.warn('Error destroying Reveal instance:', e);
                }
            }

            const revealElement = document.getElementById('reveal');
            if (!revealElement) {
                console.error('Reveal container element not found');
                return;
            }

            // Get configuration from UI
            const autoSlide = parseInt(document.getElementById('autoSlide').value) || 0;
            const autoAnimate = document.getElementById('enableAutoAnimate').checked;

            // Build Reveal.js configuration
            const revealConfig = {
                hash: true,
                controls: document.getElementById('enableControls').checked,
                progress: document.getElementById('enableProgress').checked,
                center: true,
                touch: true,
                loop: false,
                rtl: false,
                navigationMode: 'default',
                shuffle: false,
                fragments: document.getElementById('enableFragments').checked,
                embedded: false,
                help: true,
                pause: true,
                showNotes: false,
                autoPlayMedia: null,
                preloadIframes: null,
                autoAnimate: autoAnimate,
                autoAnimateMatcher: null,
                autoAnimateEasing: 'ease',
                autoAnimateDuration: 1.0,
                autoAnimateUnmatched: true,
                autoSlide: autoSlide * 1000, // Convert to milliseconds
                autoSlideStoppable: true,
                autoSlideMethod: null,
                defaultTiming: null,
                mouseWheel: false,
                previewLinks: false,
                postMessage: true,
                postMessageEvents: false,
                focusBodyOnPageVisibilityChange: true,
                transition: document.getElementById('globalTransition').value,
                transitionSpeed: document.getElementById('transitionSpeed').value,
                backgroundTransition: 'fade',
                view: null,
                viewDistance: 3,
                mobileViewDistance: 2,
                display: 'block',
                parallaxBackgroundImage: '',
                parallaxBackgroundSize: '',
                parallaxBackgroundRepeat: '',
                parallaxBackgroundPosition: '',
                parallaxBackgroundOpacity: null,
                parallaxBackgroundAngle: null
            };

            // Build plugins array conditionally
            const pluginsArray = [ 
                RevealMarkdown, 
                RevealNotes, 
                RevealHighlight, 
                RevealZoom,
                RevealSearch
            ];
            
            if (typeof RevealAppearance !== 'undefined') {
                pluginsArray.push(RevealAppearance);
            }
            if (typeof RevealChalkboard !== 'undefined') {
                pluginsArray.push(RevealChalkboard);
            }
            if (typeof RevealMenu !== 'undefined') {
                pluginsArray.push(RevealMenu);
            }
            
            revealConfig.plugins = pluginsArray;
            
            // Add plugin-specific configurations
            if (typeof RevealChalkboard !== 'undefined') {
                revealConfig.chalkboard = {
                    boardmarkerWidth: 3,
                    chalkWidth: 4,
                    chalkEffect: 0.5,
                    storage: null,
                    src: null,
                    readOnly: false,
                    toggleChalkboardButton: { left: "80px", bottom: "30px", top: "auto", right: "auto" },
                    toggleNotesButton: { left: "130px", bottom: "30px", top: "auto", right: "auto" },
                    color: [ 'rgba(0,0,255,1)', 'rgba(255,255,255,0.5)' ],
                    background: [ 'rgba(127,127,127,.1)', 'rgba(0,0,0,0)' ],
                    grid: { color: 'rgba(128,128,128,0.1)', distance: 80, width: 1 },
                    eraser: { src: null, radius: 20 }
                };
            }
            
            if (typeof RevealMenu !== 'undefined') {
                revealConfig.menu = {
                    side: 'left',
                    numbers: false,
                    titleSelector: 'h1, h2, h3, h4, h5, h6',
                    hideMissingTitles: false,
                    markers: true,
                    custom: false,
                    themes: false,
                    transitions: false,
                    openButton: true,
                    openSlideNumber: false,
                    keyboard: true,
                    sticky: false,
                    autoOpen: true,
                    delayInit: false,
                    openOnInit: false,
                    loadIcons: true
                };
            }

            reveal = new Reveal(revealConfig);

            reveal.initialize().then(() => {
                console.log('Reveal.js initialized successfully');
                updateSlideIndicator();
                
                reveal.on('slidechanged', (event) => {
                    currentSlideIndex = event.indexh;
                    currentVerticalIndex = event.indexv || 0;
                    updateSlideContent();
                    updateSlideProperties();
                    updateImageList();
                    updateShapeList();
                    currentEditingImageIndex = -1;
                    currentEditingShapeIndex = -1;
                    document.getElementById('imageEditor').style.display = 'none';
                    document.getElementById('shapeEditor').style.display = 'none';
                    updateSlideIndicator();
                });

                reveal.on('fragmentshown', (event) => {
                    console.log('Fragment shown:', event);
                });

                reveal.on('fragmenthidden', (event) => {
                    console.log('Fragment hidden:', event);
                });
            }).catch((error) => {
                console.error('Failed to initialize Reveal.js:', error);
                showNotification('Failed to initialize presentation viewer: ' + error.message, 'error');
            });
        }

        // Initialize
        async function init() {
            // Initialize Quill editor first
            initQuillEditor();
            
            setupEventListeners();
            await loadPresentations();
            
            if (!currentPresentation.slides || currentPresentation.slides.length === 0) {
                currentPresentation.slides = [{ 
                    content: '# Welcome\n\nCreate your presentation',
                    notes: '',
                    properties: {},
                    images: []
                }];
            }
            
            // Ensure all slides have images and shapes arrays
            currentPresentation.slides.forEach(slide => {
                if (!slide.images) {
                    slide.images = [];
                }
                if (!slide.shapes) {
                    slide.shapes = [];
                }
            });
            
            initReveal();
            
            // Initialize image and shape lists
            updateImageList();
            updateShapeList();
        }

        // Load presentations
        async function loadPresentations() {
            try {
                const response = await fetch(`${API_BASE}/api/graphics/presentations`);
                if (!response.ok) {
                    console.warn('Graphics API not available, starting with empty list');
                    return;
                }
                const data = await response.json();
                const select = document.getElementById('presentationSelect');
                select.innerHTML = '<option value="">New Presentation...</option>';
                data.presentations.forEach(pres => {
                    const option = document.createElement('option');
                    option.value = pres.id;
                    option.textContent = pres.name;
                    select.appendChild(option);
                });
                updatePresentationList(data.presentations);
            } catch (error) {
                console.error('Failed to load presentations:', error);
            }
        }

        // Setup event listeners
        // Update background color preview in real-time
        function updateBgColorPreview() {
            const bgColor = document.getElementById('slideBgColor').value || '#000000';
            const bgColorOpacity = parseFloat(document.getElementById('slideBgColorOpacity').value) || 100;
            const preview = document.getElementById('bgColorPreview');
            
            if (bgColor && bgColor.startsWith('#')) {
                const r = parseInt(bgColor.slice(1, 3), 16);
                const g = parseInt(bgColor.slice(3, 5), 16);
                const b = parseInt(bgColor.slice(5, 7), 16);
                const a = bgColorOpacity / 100;
                preview.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${a})`;
            } else {
                preview.style.backgroundColor = bgColor;
            }
        }

        // Template definitions
        const templates = {
            'title': {
                content: '# Title\n\n## Subtitle\n\nYour presentation description here',
                notes: 'Welcome slide template'
            },
            'content': {
                content: '## Heading\n\n- Point 1\n- Point 2\n- Point 3\n\n**Key Message**',
                notes: 'Standard content slide'
            },
            'two-column': {
                content: '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">\n  <div>\n    <h3>Left Column</h3>\n    <p>Content here</p>\n  </div>\n  <div>\n    <h3>Right Column</h3>\n    <p>Content here</p>\n  </div>\n</div>',
                notes: 'Two column layout'
            },
            'image-left': {
                content: '<div style="display: grid; grid-template-columns: 1fr 2fr; gap: 20px; align-items: center;">\n  <div>\n    <img src="https://via.placeholder.com/400x300" alt="Image" style="width: 100%;">\n  </div>\n  <div>\n    <h2>Heading</h2>\n    <p>Your content here</p>\n  </div>\n</div>',
                notes: 'Image on left, text on right'
            },
            'image-right': {
                content: '<div style="display: grid; grid-template-columns: 2fr 1fr; gap: 20px; align-items: center;">\n  <div>\n    <h2>Heading</h2>\n    <p>Your content here</p>\n  </div>\n  <div>\n    <img src="https://via.placeholder.com/400x300" alt="Image" style="width: 100%;">\n  </div>\n</div>',
                notes: 'Text on left, image on right'
            },
            'quote': {
                content: '<blockquote style="font-size: 2em; font-style: italic; text-align: center; margin: 2em 0;">\n  "Your quote here"\n</blockquote>\n<p style="text-align: center; font-size: 1.2em;">‚Äî Author Name</p>',
                notes: 'Quote slide template'
            },
            'code': {
                content: '## Code Example\n\n```python\ndef hello():\n    print("Hello, World!")\n```',
                notes: 'Code slide template'
            }
        };

        // Apply template to current slide
        function applyTemplate() {
            const templateId = document.getElementById('templateSelect').value;
            if (!templateId || !templates[templateId]) {
                if (typeof showNotification === 'function') {
                    showNotification('Please select a template', 'warning');
                } else {
                    alert('Please select a template');
                }
                return;
            }

            const template = templates[templateId];
            
            // Update content
            document.getElementById('slideContent').value = template.content;
            
            // Update Quill if in visual mode
            if (quillEditor && editorMode === 'visual') {
                const html = markdownToQuill(template.content);
                quillEditor.root.innerHTML = html;
            }
            
            // Update notes if provided
            if (template.notes) {
                document.getElementById('slideNotes').value = template.notes;
            }
            
            // Update the slide
            updateSlide();
            
            // Reset template selector
            document.getElementById('templateSelect').value = '';
            
            // Show success message if showNotification exists
            if (typeof showNotification === 'function') {
                showNotification(`Template "${templateId}" applied`, 'success');
            } else {
                console.log(`Template "${templateId}" applied successfully`);
            }
        }

        function setupEventListeners() {
            document.getElementById('presentationSelect').addEventListener('change', handlePresentationSelect);
            document.getElementById('saveBtn').addEventListener('click', savePresentation);
            document.getElementById('exportBtn').addEventListener('click', exportToMixer);
            document.getElementById('fullscreenBtn').addEventListener('click', toggleFullscreen);
            document.getElementById('addSlideBtn').addEventListener('click', addSlide);
            document.getElementById('addVerticalSlideBtn').addEventListener('click', addVerticalSlide);
            document.getElementById('removeSlideBtn').addEventListener('click', removeSlide);
            document.getElementById('updateSlideBtn').addEventListener('click', updateSlide);
            document.getElementById('applyTemplateBtn').addEventListener('click', applyTemplate);
            document.getElementById('toggleEditorMode').addEventListener('click', function() {
                editorMode = editorMode === 'visual' ? 'markdown' : 'visual';
                toggleEditorMode();
            });
            
            // Enhanced media management
            document.getElementById('addImageFile').addEventListener('change', async function(e) {
                const files = Array.from(e.target.files);
                for (const file of files) {
                    await uploadAndAddImage(file);
                }
                e.target.value = ''; // Reset input
            });
            
            document.getElementById('browseMediaBtn').addEventListener('click', function() {
                showMediaLibrary();
            });
            
            document.getElementById('refreshMediaBtn').addEventListener('click', function() {
                if (typeof updateImageList === 'function') {
                    updateImageList();
                }
                showNotification('Media library refreshed', 'success');
            });
            document.getElementById('prevBtn').addEventListener('click', () => {
                if (reveal) reveal.prev();
            });
            document.getElementById('nextBtn').addEventListener('click', () => {
                if (reveal) reveal.next();
            });
            document.getElementById('themeSelect').addEventListener('change', changeTheme);
            document.getElementById('globalTransition').addEventListener('change', updateGlobalSettings);
            document.getElementById('transitionSpeed').addEventListener('change', updateGlobalSettings);
            document.getElementById('enableControls').addEventListener('change', updateGlobalSettings);
            document.getElementById('enableProgress').addEventListener('change', updateGlobalSettings);
            document.getElementById('enableFragments').addEventListener('change', updateGlobalSettings);
            document.getElementById('enableAutoAnimate').addEventListener('change', updateGlobalSettings);
            document.getElementById('autoSlide').addEventListener('change', updateGlobalSettings);
            document.getElementById('uploadImageBtn').addEventListener('change', handleImageUpload);
            document.getElementById('uploadVideoBtn').addEventListener('change', handleVideoUpload);
            document.getElementById('addImageBtn').addEventListener('change', handleAddImageToSlide);
            document.getElementById('updateImageBtn').addEventListener('click', updateImageProperties);
            document.getElementById('removeImageBtn').addEventListener('click', removeCurrentImage);
            
            // Image property change listeners
            ['imageX', 'imageY', 'imageWidth', 'imageHeight', 'imageCropX', 'imageCropY', 'imageCropWidth', 'imageCropHeight', 'imageBorderRadius', 'imageObjectFit', 'imageOpacity'].forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('input', updateImagePreview);
                }
            });
            
            // Shape event listeners
            document.getElementById('addShapeBtn').addEventListener('click', addShape);
            document.getElementById('updateShapeBtn').addEventListener('click', updateShapeProperties);
            document.getElementById('removeShapeBtn').addEventListener('click', removeCurrentShape);
            document.getElementById('shapeFillType').addEventListener('change', updateShapeFillType);
            document.getElementById('addGradientColorBtn').addEventListener('click', addGradientColorStop);
            document.getElementById('uploadShapeImageBtn').addEventListener('change', handleShapeImageUpload);
            
            // Shape property change listeners
            ['shapeX', 'shapeY', 'shapeWidth', 'shapeHeight', 'shapeColor', 'shapeColorOpacity', 'shapeBorderWidth', 'shapeBorderColor', 'shapeBorderOpacity', 'shapeBorderRadius', 'shapeOpacity', 'shapeRotation'].forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('input', updateShapePreview);
                }
            });
            
            // Background color preview listeners
            const bgColorInput = document.getElementById('slideBgColor');
            const bgOpacityInput = document.getElementById('slideBgColorOpacity');
            const bgPreview = document.getElementById('bgColorPreview');
            
            if (bgColorInput) {
                bgColorInput.addEventListener('input', updateBgColorPreview);
                bgColorInput.addEventListener('change', updateBgColorPreview);
            }
            if (bgOpacityInput) {
                bgOpacityInput.addEventListener('input', updateBgColorPreview);
                bgOpacityInput.addEventListener('change', updateBgColorPreview);
            }
            if (bgPreview) {
                bgPreview.addEventListener('click', () => {
                    // Apply background immediately on preview click
                    updateSlide();
                });
            }
        }
        
        let currentEditingImageIndex = -1;
        
        // Enhanced: Upload and add image (for multiple files)
        async function uploadAndAddImage(file) {
            if (!file.type.startsWith('image/')) {
                if (typeof showNotification === 'function') {
                    showNotification('Please select an image file', 'error');
                }
                return;
            }

            const formData = new FormData();
            formData.append('file', file);

            try {
                if (typeof showNotification === 'function') {
                    showNotification('Uploading image...');
                }
                const response = await fetch(`${API_BASE}/api/graphics/upload/image`, {
                    method: 'POST',
                    body: formData
                });

                if (response.ok) {
                    const data = await response.json();
                    const imageUrl = `${API_BASE}${data.url}`;
                    
                    // Add image to current slide
                    if (!currentPresentation.slides) {
                        currentPresentation.slides = [];
                    }
                    while (currentPresentation.slides.length <= currentSlideIndex) {
                        currentPresentation.slides.push({ content: '', notes: '', properties: {}, images: [] });
                    }
                    
                    if (!currentPresentation.slides[currentSlideIndex].images) {
                        currentPresentation.slides[currentSlideIndex].images = [];
                    }
                    
                    const newImage = {
                        url: imageUrl,
                        x: 50,
                        y: 50,
                        width: 50,
                        height: 50,
                        cropX: 0,
                        cropY: 0,
                        cropWidth: 100,
                        cropHeight: 100,
                        borderRadius: 0,
                        objectFit: 'contain',
                        opacity: 100
                    };
                    
                    currentPresentation.slides[currentSlideIndex].images.push(newImage);
                    if (typeof updateImageList === 'function') {
                        updateImageList();
                    }
                    loadSlidesIntoReveal(currentPresentation.slides);
                    if (typeof showNotification === 'function') {
                        showNotification('Image added successfully');
                    }
                } else {
                    const error = await response.text();
                    if (typeof showNotification === 'function') {
                        showNotification('Failed to upload image: ' + error, 'error');
                    }
                }
            } catch (error) {
                console.error('Failed to upload image:', error);
                if (typeof showNotification === 'function') {
                    showNotification('Failed to upload image', 'error');
                }
            }
        }
        
        // Enhanced: Show media library browser
        async function showMediaLibrary() {
            try {
                // Fetch uploaded images from server
                const response = await fetch(`${API_BASE}/api/graphics/media`);
                if (response.ok) {
                    const media = await response.json();
                    // Create modal or panel to show media library
                    // For now, just log - can be enhanced with a modal UI
                    console.log('Media library:', media);
                    if (typeof showNotification === 'function') {
                        showNotification('Media library: ' + (media.length || 0) + ' items', 'success');
                    }
                } else {
                    // If endpoint doesn't exist, show message
                    if (typeof showNotification === 'function') {
                        showNotification('Media library feature coming soon', 'info');
                    }
                }
            } catch (error) {
                console.log('Media library not available:', error);
                if (typeof showNotification === 'function') {
                    showNotification('Media library feature coming soon', 'info');
                }
            }
        }
        
        // Handle adding image to slide content
        async function handleAddImageToSlide(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!file.type.startsWith('image/')) {
                showNotification('Please select an image file', 'error');
                return;
            }

            const formData = new FormData();
            formData.append('file', file);

            try {
                showNotification('Uploading image...');
                const response = await fetch(`${API_BASE}/api/graphics/upload/image`, {
                    method: 'POST',
                    body: formData
                });

                if (response.ok) {
                    const data = await response.json();
                    const imageUrl = `${API_BASE}${data.url}`;
                    
                    // Add image to current slide
                    if (!currentPresentation.slides) {
                        currentPresentation.slides = [];
                    }
                    while (currentPresentation.slides.length <= currentSlideIndex) {
                        currentPresentation.slides.push({ content: '', notes: '', properties: {}, images: [] });
                    }
                    
                    if (!currentPresentation.slides[currentSlideIndex].images) {
                        currentPresentation.slides[currentSlideIndex].images = [];
                    }
                    
                    const newImage = {
                        url: imageUrl,
                        x: 50,
                        y: 50,
                        width: 50,
                        height: 50,
                        cropX: 0,
                        cropY: 0,
                        cropWidth: 100,
                        cropHeight: 100,
                        borderRadius: 0,
                        objectFit: 'contain',
                        opacity: 100
                    };
                    
                    currentPresentation.slides[currentSlideIndex].images.push(newImage);
                    updateImageList();
                    editImage(currentPresentation.slides[currentSlideIndex].images.length - 1);
                    loadSlidesIntoReveal(currentPresentation.slides);
                    showNotification('Image added successfully');
                } else {
                    const error = await response.text();
                    showNotification('Failed to upload image: ' + error, 'error');
                }
            } catch (error) {
                console.error('Failed to upload image:', error);
                showNotification('Failed to upload image', 'error');
            }

            // Reset file input
            event.target.value = '';
        }
        
        // Update image list display
        function updateImageList() {
            const imageList = document.getElementById('imageList');
            imageList.innerHTML = '';
            
            if (!currentPresentation.slides || currentSlideIndex >= currentPresentation.slides.length) {
                imageList.innerHTML = '<div class="empty-state"><div class="empty-state-text">No slide selected</div></div>';
                return;
            }
            
            const slide = currentPresentation.slides[currentSlideIndex];
            if (!slide.images || slide.images.length === 0) {
                imageList.innerHTML = '<div class="empty-state"><div class="empty-state-icon">üñºÔ∏è</div><div class="empty-state-text">No images on this slide<br>Click "Upload & Add" to add an image</div></div>';
                return;
            }
            
            slide.images.forEach((img, index) => {
                const item = document.createElement('div');
                item.className = 'list-item' + (currentEditingImageIndex === index ? ' active' : '');
                item.innerHTML = `
                    <img src="${img.url}" class="list-item-thumbnail" alt="Image ${index + 1}">
                    <div class="list-item-content">
                        <div class="list-item-title">Image ${index + 1}</div>
                        <div class="list-item-subtitle">${img.url.split('/').pop()}</div>
                    </div>
                `;
                item.addEventListener('click', () => editImage(index));
                imageList.appendChild(item);
            });
        }
        
        // Edit image properties
        function editImage(index) {
            if (!currentPresentation.slides || currentSlideIndex >= currentPresentation.slides.length) {
                return;
            }
            
            const slide = currentPresentation.slides[currentSlideIndex];
            if (!slide.images || index >= slide.images.length) {
                return;
            }
            
            currentEditingImageIndex = index;
            const img = slide.images[index];
            
            document.getElementById('imageUrl').value = img.url;
            document.getElementById('imageX').value = img.x || 50;
            document.getElementById('imageY').value = img.y || 50;
            document.getElementById('imageWidth').value = img.width || 50;
            document.getElementById('imageHeight').value = img.height || 50;
            document.getElementById('imageCropX').value = img.cropX || 0;
            document.getElementById('imageCropY').value = img.cropY || 0;
            document.getElementById('imageCropWidth').value = img.cropWidth || 100;
            document.getElementById('imageCropHeight').value = img.cropHeight || 100;
            document.getElementById('imageBorderRadius').value = img.borderRadius || 0;
            document.getElementById('imageObjectFit').value = img.objectFit || 'contain';
            document.getElementById('imageOpacity').value = img.opacity || 100;
            
            document.getElementById('imageEditor').style.display = 'block';
            updateImageList();
        }
        
        // Update image properties
        function updateImageProperties() {
            if (currentEditingImageIndex < 0) return;
            
            if (!currentPresentation.slides || currentSlideIndex >= currentPresentation.slides.length) {
                return;
            }
            
            const slide = currentPresentation.slides[currentSlideIndex];
            if (!slide.images || currentEditingImageIndex >= slide.images.length) {
                return;
            }
            
            const img = slide.images[currentEditingImageIndex];
            img.x = parseFloat(document.getElementById('imageX').value) || 50;
            img.y = parseFloat(document.getElementById('imageY').value) || 50;
            img.width = parseFloat(document.getElementById('imageWidth').value) || 50;
            img.height = parseFloat(document.getElementById('imageHeight').value) || 50;
            img.cropX = parseFloat(document.getElementById('imageCropX').value) || 0;
            img.cropY = parseFloat(document.getElementById('imageCropY').value) || 0;
            img.cropWidth = parseFloat(document.getElementById('imageCropWidth').value) || 100;
            img.cropHeight = parseFloat(document.getElementById('imageCropHeight').value) || 100;
            img.borderRadius = parseFloat(document.getElementById('imageBorderRadius').value) || 0;
            img.objectFit = document.getElementById('imageObjectFit').value || 'contain';
            img.opacity = parseFloat(document.getElementById('imageOpacity').value) || 100;
            
            loadSlidesIntoReveal(currentPresentation.slides);
            updateImageList();
            showNotification('Image updated');
        }
        
        // Remove current image
        function removeCurrentImage() {
            if (currentEditingImageIndex < 0) return;
            
            if (!currentPresentation.slides || currentSlideIndex >= currentPresentation.slides.length) {
                return;
            }
            
            const slide = currentPresentation.slides[currentSlideIndex];
            if (!slide.images || currentEditingImageIndex >= slide.images.length) {
                return;
            }
            
            slide.images.splice(currentEditingImageIndex, 1);
            currentEditingImageIndex = -1;
            document.getElementById('imageEditor').style.display = 'none';
            updateImageList();
            loadSlidesIntoReveal(currentPresentation.slides);
            showNotification('Image removed');
        }
        
        // Update image preview (real-time updates)
        function updateImagePreview() {
            if (currentEditingImageIndex < 0) return;
            updateImageProperties();
        }
        
        let currentEditingShapeIndex = -1;
        let gradientColorStops = [];
        
        // Add shape
        function addShape() {
            if (!currentPresentation.slides) {
                currentPresentation.slides = [];
            }
            while (currentPresentation.slides.length <= currentSlideIndex) {
                currentPresentation.slides.push({ content: '', notes: '', properties: {}, images: [], shapes: [] });
            }
            
            if (!currentPresentation.slides[currentSlideIndex].shapes) {
                currentPresentation.slides[currentSlideIndex].shapes = [];
            }
            
            const shapeType = document.getElementById('shapeType').value;
            const newShape = {
                type: shapeType,
                x: 50,
                y: 50,
                width: 30,
                height: 30,
                fillType: 'color',
                color: '#3b82f6',
                colorOpacity: 100,
                imageUrl: '',
                gradientType: 'linear',
                gradientDirection: 'to right',
                gradientColors: [{ color: '#3b82f6', stop: 0 }, { color: '#8b5cf6', stop: 100 }],
                borderWidth: 0,
                borderColor: '#000000',
                borderOpacity: 100,
                borderRadius: 0,
                opacity: 100,
                rotation: 0
            };
            
            currentPresentation.slides[currentSlideIndex].shapes.push(newShape);
            updateShapeList();
            editShape(currentPresentation.slides[currentSlideIndex].shapes.length - 1);
            loadSlidesIntoReveal(currentPresentation.slides);
            showNotification('Shape added');
        }
        
        // Update shape list display
        function updateShapeList() {
            const shapeList = document.getElementById('shapeList');
            shapeList.innerHTML = '';
            
            if (!currentPresentation.slides || currentSlideIndex >= currentPresentation.slides.length) {
                shapeList.innerHTML = '<div class="empty-state"><div class="empty-state-text">No slide selected</div></div>';
                return;
            }
            
            const slide = currentPresentation.slides[currentSlideIndex];
            if (!slide.shapes || slide.shapes.length === 0) {
                shapeList.innerHTML = '<div class="empty-state"><div class="empty-state-icon">üî∑</div><div class="empty-state-text">No shapes on this slide<br>Select a shape type and click "Add Shape"</div></div>';
                return;
            }
            
            slide.shapes.forEach((shape, index) => {
                const item = document.createElement('div');
                item.className = 'list-item' + (currentEditingShapeIndex === index ? ' active' : '');
                
                // Create preview thumbnail
                let previewStyle = '';
                if (shape.fillType === 'color') {
                    const opacity = (shape.colorOpacity || 100) / 100;
                    const color = shape.color || '#3b82f6';
                    if (color.startsWith('#')) {
                        const r = parseInt(color.slice(1, 3), 16);
                        const g = parseInt(color.slice(3, 5), 16);
                        const b = parseInt(color.slice(5, 7), 16);
                        previewStyle = `background: rgba(${r}, ${g}, ${b}, ${opacity});`;
                    } else {
                        previewStyle = `background: ${color};`;
                    }
                } else if (shape.fillType === 'gradient' && shape.gradientColors) {
                    const colors = shape.gradientColors.map(c => `${c.color} ${c.stop}%`).join(', ');
                    if (shape.gradientType === 'radial') {
                        previewStyle = `background: radial-gradient(circle, ${colors});`;
                    } else if (shape.gradientType === 'conic') {
                        previewStyle = `background: conic-gradient(${colors});`;
                    } else {
                        previewStyle = `background: linear-gradient(${shape.gradientDirection || 'to right'}, ${colors});`;
                    }
                } else {
                    previewStyle = 'background: #888;';
                }
                
                item.innerHTML = `
                    <div class="list-item-thumbnail" style="${previewStyle}"></div>
                    <div class="list-item-content">
                        <div class="list-item-title">${shape.type.charAt(0).toUpperCase() + shape.type.slice(1)}</div>
                        <div class="list-item-subtitle">${shape.fillType} ‚Ä¢ ${shape.width}% √ó ${shape.height}%</div>
                    </div>
                `;
                item.addEventListener('click', () => editShape(index));
                shapeList.appendChild(item);
            });
        }
        
        // Edit shape properties
        function editShape(index) {
            if (!currentPresentation.slides || currentSlideIndex >= currentPresentation.slides.length) {
                return;
            }
            
            const slide = currentPresentation.slides[currentSlideIndex];
            if (!slide.shapes || index >= slide.shapes.length) {
                return;
            }
            
            currentEditingShapeIndex = index;
            const shape = slide.shapes[index];
            
            document.getElementById('shapeTypeDisplay').value = shape.type;
            document.getElementById('shapeX').value = shape.x || 50;
            document.getElementById('shapeY').value = shape.y || 50;
            document.getElementById('shapeWidth').value = shape.width || 30;
            document.getElementById('shapeHeight').value = shape.height || 30;
            document.getElementById('shapeFillType').value = shape.fillType || 'color';
            document.getElementById('shapeColor').value = shape.color || '#3b82f6';
            document.getElementById('shapeColorOpacity').value = shape.colorOpacity || 100;
            document.getElementById('shapeImageUrl').value = shape.imageUrl || '';
            document.getElementById('shapeGradientType').value = shape.gradientType || 'linear';
            document.getElementById('shapeGradientDirection').value = shape.gradientDirection || 'to right';
            document.getElementById('shapeBorderWidth').value = shape.borderWidth || 0;
            document.getElementById('shapeBorderColor').value = shape.borderColor || '#000000';
            document.getElementById('shapeBorderOpacity').value = shape.borderOpacity || 100;
            document.getElementById('shapeBorderRadius').value = shape.borderRadius || 0;
            document.getElementById('shapeOpacity').value = shape.opacity || 100;
            document.getElementById('shapeRotation').value = shape.rotation || 0;
            
            // Setup gradient colors
            if (shape.gradientColors && shape.gradientColors.length > 0) {
                gradientColorStops = [...shape.gradientColors];
                document.getElementById('shapeGradientColor1').value = shape.gradientColors[0].color || '#3b82f6';
                document.getElementById('shapeGradientStop1').value = shape.gradientColors[0].stop || 0;
                if (shape.gradientColors.length > 1) {
                    document.getElementById('shapeGradientColor2').value = shape.gradientColors[1].color || '#8b5cf6';
                    document.getElementById('shapeGradientStop2').value = shape.gradientColors[1].stop || 100;
                }
                updateGradientColorStops();
            } else {
                gradientColorStops = [{ color: '#3b82f6', stop: 0 }, { color: '#8b5cf6', stop: 100 }];
            }
            
            updateShapeFillType();
            document.getElementById('shapeEditor').style.display = 'block';
            updateShapeList();
        }
        
        // Update shape fill type display
        function updateShapeFillType() {
            const fillType = document.getElementById('shapeFillType').value;
            document.getElementById('shapeFillColor').style.display = fillType === 'color' ? 'block' : 'none';
            document.getElementById('shapeFillImage').style.display = fillType === 'image' ? 'block' : 'none';
            document.getElementById('shapeFillGradient').style.display = fillType === 'gradient' ? 'block' : 'none';
        }
        
        // Add gradient color stop
        function addGradientColorStop() {
            const color = document.getElementById('shapeGradientColor2').value;
            const stop = parseFloat(document.getElementById('shapeGradientStop2').value) || 100;
            gradientColorStops.push({ color, stop });
            updateGradientColorStops();
        }
        
        // Update gradient color stops display
        function updateGradientColorStops() {
            const container = document.getElementById('gradientColorStops');
            container.innerHTML = '';
            
            const additionalStops = gradientColorStops.filter((stop, index) => index >= 2);
            
            if (additionalStops.length === 0) {
                return;
            }
            
            additionalStops.forEach((stop, localIndex) => {
                const actualIndex = localIndex + 2;
                const div = document.createElement('div');
                div.style.cssText = 'display: flex; gap: 8px; align-items: center; margin-bottom: 8px; padding: 12px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px;';
                div.innerHTML = `
                    <div class="color-picker-wrapper" style="flex: 1;">
                        <input type="color" value="${stop.color}" class="form-input" style="height: 40px; width: 100%;" onchange="gradientColorStops[${actualIndex}].color = this.value; updateGradientColorStops(); updateShapePreview();">
                    </div>
                    <div class="input-group" style="width: 120px;">
                        <input type="number" value="${stop.stop}" min="0" max="100" step="1" class="form-input" onchange="gradientColorStops[${actualIndex}].stop = parseFloat(this.value); updateGradientColorStops(); updateShapePreview();">
                        <span class="input-group-label">%</span>
                    </div>
                    <button type="button" class="btn btn-danger btn-small" onclick="if(gradientColorStops.length > 2) { gradientColorStops.splice(${actualIndex}, 1); updateGradientColorStops(); updateShapePreview(); } else { showNotification('Gradient needs at least 2 color stops', 'error'); }" style="min-width: 80px;">Remove</button>
                `;
                container.appendChild(div);
            });
        }
        
        // Handle shape image upload
        async function handleShapeImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!file.type.startsWith('image/')) {
                showNotification('Please select an image file', 'error');
                return;
            }

            const formData = new FormData();
            formData.append('file', file);

            try {
                showNotification('Uploading image...');
                const response = await fetch(`${API_BASE}/api/graphics/upload/image`, {
                    method: 'POST',
                    body: formData
                });

                if (response.ok) {
                    const data = await response.json();
                    const imageUrl = `${API_BASE}${data.url}`;
                    document.getElementById('shapeImageUrl').value = imageUrl;
                    showNotification('Image uploaded successfully');
                } else {
                    const error = await response.text();
                    showNotification('Failed to upload image: ' + error, 'error');
                }
            } catch (error) {
                console.error('Failed to upload image:', error);
                showNotification('Failed to upload image', 'error');
            }

            event.target.value = '';
        }
        
        // Update shape properties
        function updateShapeProperties() {
            if (currentEditingShapeIndex < 0) return;
            
            if (!currentPresentation.slides || currentSlideIndex >= currentPresentation.slides.length) {
                return;
            }
            
            const slide = currentPresentation.slides[currentSlideIndex];
            if (!slide.shapes || currentEditingShapeIndex >= slide.shapes.length) {
                return;
            }
            
            const shape = slide.shapes[currentEditingShapeIndex];
            shape.x = parseFloat(document.getElementById('shapeX').value) || 50;
            shape.y = parseFloat(document.getElementById('shapeY').value) || 50;
            shape.width = parseFloat(document.getElementById('shapeWidth').value) || 30;
            shape.height = parseFloat(document.getElementById('shapeHeight').value) || 30;
            shape.fillType = document.getElementById('shapeFillType').value || 'color';
            shape.color = document.getElementById('shapeColor').value || '#3b82f6';
            shape.colorOpacity = parseFloat(document.getElementById('shapeColorOpacity').value) || 100;
            shape.imageUrl = document.getElementById('shapeImageUrl').value || '';
            shape.gradientType = document.getElementById('shapeGradientType').value || 'linear';
            shape.gradientDirection = document.getElementById('shapeGradientDirection').value || 'to right';
            shape.borderWidth = parseFloat(document.getElementById('shapeBorderWidth').value) || 0;
            shape.borderColor = document.getElementById('shapeBorderColor').value || '#000000';
            shape.borderOpacity = parseFloat(document.getElementById('shapeBorderOpacity').value) || 100;
            shape.borderRadius = parseFloat(document.getElementById('shapeBorderRadius').value) || 0;
            shape.opacity = parseFloat(document.getElementById('shapeOpacity').value) || 100;
            shape.rotation = parseFloat(document.getElementById('shapeRotation').value) || 0;
            
            // Update gradient colors
            gradientColorStops[0] = { color: document.getElementById('shapeGradientColor1').value, stop: parseFloat(document.getElementById('shapeGradientStop1').value) || 0 };
            gradientColorStops[1] = { color: document.getElementById('shapeGradientColor2').value, stop: parseFloat(document.getElementById('shapeGradientStop2').value) || 100 };
            shape.gradientColors = [...gradientColorStops];
            
            loadSlidesIntoReveal(currentPresentation.slides);
            updateShapeList();
            showNotification('Shape updated');
        }
        
        // Remove current shape
        function removeCurrentShape() {
            if (currentEditingShapeIndex < 0) return;
            
            if (!currentPresentation.slides || currentSlideIndex >= currentPresentation.slides.length) {
                return;
            }
            
            const slide = currentPresentation.slides[currentSlideIndex];
            if (!slide.shapes || currentEditingShapeIndex >= slide.shapes.length) {
                return;
            }
            
            slide.shapes.splice(currentEditingShapeIndex, 1);
            currentEditingShapeIndex = -1;
            document.getElementById('shapeEditor').style.display = 'none';
            updateShapeList();
            loadSlidesIntoReveal(currentPresentation.slides);
            showNotification('Shape removed');
        }
        
        // Update shape preview (real-time updates)
        function updateShapePreview() {
            if (currentEditingShapeIndex < 0) return;
            updateShapeProperties();
        }

        // Handle image upload
        async function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!file.type.startsWith('image/')) {
                showNotification('Please select an image file', 'error');
                return;
            }

            const formData = new FormData();
            formData.append('file', file);

            try {
                showNotification('Uploading image...');
                const response = await fetch(`${API_BASE}/api/graphics/upload/image`, {
                    method: 'POST',
                    body: formData
                });

                if (response.ok) {
                    const data = await response.json();
                    const imageUrl = `${API_BASE}${data.url}`;
                    document.getElementById('slideBgImage').value = imageUrl;
                    showNotification('Image uploaded successfully');
                } else {
                    const error = await response.text();
                    showNotification('Failed to upload image: ' + error, 'error');
                }
            } catch (error) {
                console.error('Failed to upload image:', error);
                showNotification('Failed to upload image', 'error');
            }

            // Reset file input
            event.target.value = '';
        }

        // Handle video upload
        async function handleVideoUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!file.type.startsWith('video/')) {
                showNotification('Please select a video file', 'error');
                return;
            }

            const formData = new FormData();
            formData.append('file', file);

            try {
                showNotification('Uploading video...');
                const response = await fetch(`${API_BASE}/api/graphics/upload/video`, {
                    method: 'POST',
                    body: formData
                });

                if (response.ok) {
                    const data = await response.json();
                    const videoUrl = `${API_BASE}${data.url}`;
                    document.getElementById('slideBgVideo').value = videoUrl;
                    showNotification('Video uploaded successfully');
                } else {
                    const error = await response.text();
                    showNotification('Failed to upload video: ' + error, 'error');
                }
            } catch (error) {
                console.error('Failed to upload video:', error);
                showNotification('Failed to upload video', 'error');
            }

            // Reset file input
            event.target.value = '';
        }

        // Update global settings
        function updateGlobalSettings() {
            if (!reveal) return;
            
            const transition = document.getElementById('globalTransition').value;
            const speed = document.getElementById('transitionSpeed').value;
            const autoSlide = parseInt(document.getElementById('autoSlide').value) || 0;
            const autoAnimate = document.getElementById('enableAutoAnimate').checked;

            reveal.configure({
                transition: transition,
                transitionSpeed: speed,
                autoSlide: autoSlide * 1000,
                autoAnimate: autoAnimate,
                controls: document.getElementById('enableControls').checked,
                progress: document.getElementById('enableProgress').checked,
                fragments: document.getElementById('enableFragments').checked
            });

            currentPresentation.transition = transition;
            currentPresentation.transitionSpeed = speed;
            currentPresentation.autoSlide = autoSlide;
            currentPresentation.autoAnimate = autoAnimate;
        }

        // Handle presentation select
        async function handlePresentationSelect(e) {
            const presId = e.target.value;
            if (!presId) {
                currentPresentation = {
                    id: '',
                    name: '',
                    theme: 'black',
                    transition: 'slide',
                    transitionSpeed: 'default',
                    controls: true,
                    progress: true,
                    fragments: true,
                    autoAnimate: false,
                    autoSlide: 0,
                    slides: [{ content: '# Welcome\n\nCreate your presentation', notes: '', properties: {}, images: [], shapes: [] }]
                };
                document.getElementById('presentationName').value = '';
                document.getElementById('presentationId').value = '';
                document.getElementById('themeSelect').value = 'black';
                document.getElementById('globalTransition').value = 'slide';
                document.getElementById('transitionSpeed').value = 'default';
                document.getElementById('enableControls').checked = true;
                document.getElementById('enableProgress').checked = true;
                document.getElementById('enableFragments').checked = true;
                document.getElementById('enableAutoAnimate').checked = false;
                document.getElementById('autoSlide').value = '0';
                loadSlidesIntoReveal(currentPresentation.slides);
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/api/graphics/presentations/${presId}`);
                if (!response.ok) throw new Error('Failed to load presentation');
                const pres = await response.json();
                currentPresentation = {
                    id: pres.id || presId,
                    name: pres.name || pres.id || presId,
                    theme: pres.theme || 'black',
                    transition: pres.transition || 'slide',
                    transitionSpeed: pres.transitionSpeed || 'default',
                    controls: pres.controls !== false,
                    progress: pres.progress !== false,
                    fragments: pres.fragments !== false,
                    autoAnimate: pres.autoAnimate || false,
                    autoSlide: pres.autoSlide || 0,
                    slides: pres.slides || []
                };
                document.getElementById('presentationName').value = currentPresentation.name;
                document.getElementById('presentationId').value = currentPresentation.id;
                document.getElementById('themeSelect').value = currentPresentation.theme;
                document.getElementById('globalTransition').value = currentPresentation.transition;
                document.getElementById('transitionSpeed').value = currentPresentation.transitionSpeed;
                document.getElementById('enableControls').checked = currentPresentation.controls;
                document.getElementById('enableProgress').checked = currentPresentation.progress;
                document.getElementById('enableFragments').checked = currentPresentation.fragments;
                document.getElementById('enableAutoAnimate').checked = currentPresentation.autoAnimate;
                document.getElementById('autoSlide').value = currentPresentation.autoSlide;
                loadSlidesIntoReveal(currentPresentation.slides);
                changeTheme();
            } catch (error) {
                console.error('Failed to load presentation:', error);
                showNotification('Failed to load presentation', 'error');
            }
        }

        // Load slides into Reveal.js
        function loadSlidesIntoReveal(slides) {
            if (!slides || slides.length === 0) {
                slides = [{ content: '# Welcome\n\nCreate your presentation', notes: '', properties: {}, images: [], shapes: [] }];
            }

            const slidesContainer = document.getElementById('slides');
            slidesContainer.innerHTML = '';
            
            slides.forEach((slide, index) => {
                const section = document.createElement('section');
                
                // Ensure images array exists
                if (!slide.images) {
                    slide.images = [];
                }
                
                // Apply slide properties
                const props = slide.properties || {};
                if (props.transition) section.setAttribute('data-transition', props.transition);
                // Always set background - even if it's black or default
                if (props.background) {
                    section.setAttribute('data-background', props.background);
                } else {
                    // Default to black if no background specified
                    section.setAttribute('data-background', '#000000');
                }
                if (props.backgroundImage) section.setAttribute('data-background-image', props.backgroundImage);
                if (props.backgroundVideo) section.setAttribute('data-background-video', props.backgroundVideo);
                if (props.backgroundSize) section.setAttribute('data-background-size', props.backgroundSize);
                if (props.autoAnimate) section.setAttribute('data-auto-animate', '');
                if (props.autoAnimateDuration) section.setAttribute('data-auto-animate-duration', props.autoAnimateDuration);
                if (props.autoAnimateEasing) section.setAttribute('data-auto-animate-easing', props.autoAnimateEasing);
                
                section.setAttribute('data-markdown', '');
                
                // Add speaker notes if present
                if (slide.notes) {
                    const notesElement = document.createElement('aside');
                    notesElement.className = 'notes';
                    notesElement.setAttribute('data-markdown', '');
                    const notesScript = document.createElement('script');
                    notesScript.type = 'text/template';
                    notesScript.textContent = slide.notes;
                    notesElement.appendChild(notesScript);
                    section.appendChild(notesElement);
                }
                
                const script = document.createElement('script');
                script.type = 'text/template';
                script.textContent = slide.content || '';
                section.appendChild(script);
                
                // Add images if present
                if (slide.images && slide.images.length > 0) {
                    const imagesContainer = document.createElement('div');
                    imagesContainer.className = 'slide-images-container';
                    imagesContainer.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10;';
                    
                    slide.images.forEach((img) => {
                        const imgElement = document.createElement('img');
                        imgElement.src = img.url;
                        imgElement.style.cssText = `
                            position: absolute;
                            left: ${img.x}%;
                            top: ${img.y}%;
                            width: ${img.width}%;
                            height: ${img.height}%;
                            object-fit: ${img.objectFit || 'contain'};
                            border-radius: ${img.borderRadius || 0}px;
                            opacity: ${(img.opacity || 100) / 100};
                            transform: translate(-50%, -50%);
                            pointer-events: auto;
                        `;
                        
                        // Apply cropping using clip-path
                        if (img.cropX !== undefined && img.cropY !== undefined && 
                            img.cropWidth !== undefined && img.cropHeight !== undefined &&
                            (img.cropX !== 0 || img.cropY !== 0 || img.cropWidth !== 100 || img.cropHeight !== 100)) {
                            const clipX = img.cropX;
                            const clipY = img.cropY;
                            const clipWidth = img.cropWidth;
                            const clipHeight = img.cropHeight;
                            imgElement.style.clipPath = `inset(${clipY}% ${100 - clipX - clipWidth}% ${100 - clipY - clipHeight}% ${clipX}%)`;
                        }
                        
                        imagesContainer.appendChild(imgElement);
                    });
                    
                    section.appendChild(imagesContainer);
                }
                
                // Add shapes if present
                if (slide.shapes && slide.shapes.length > 0) {
                    const shapesContainer = document.createElement('div');
                    shapesContainer.className = 'slide-shapes-container';
                    shapesContainer.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 9;';
                    
                    slide.shapes.forEach((shape) => {
                        const shapeElement = document.createElement('div');
                        shapeElement.style.cssText = `
                            position: absolute;
                            left: ${shape.x}%;
                            top: ${shape.y}%;
                            width: ${shape.width}%;
                            height: ${shape.height}%;
                            opacity: ${(shape.opacity || 100) / 100};
                            transform: translate(-50%, -50%) rotate(${shape.rotation || 0}deg);
                            pointer-events: auto;
                        `;
                        
                        // Set shape type
                        if (shape.type === 'circle' || shape.type === 'ellipse') {
                            shapeElement.style.borderRadius = '50%';
                        } else if (shape.type === 'triangle') {
                            shapeElement.style.width = '0';
                            shapeElement.style.height = '0';
                            shapeElement.style.borderLeft = `${shape.width / 2}% solid transparent`;
                            shapeElement.style.borderRight = `${shape.width / 2}% solid transparent`;
                            shapeElement.style.borderBottom = `${shape.height}% solid`;
                            shapeElement.style.borderTop = 'none';
                            shapeElement.style.background = 'none';
                        } else {
                            shapeElement.style.borderRadius = `${shape.borderRadius || 0}px`;
                        }
                        
                        // Set fill
                        if (shape.fillType === 'color') {
                            const opacity = (shape.colorOpacity || 100) / 100;
                            const color = shape.color || '#3b82f6';
                            if (color.startsWith('#')) {
                                const r = parseInt(color.slice(1, 3), 16);
                                const g = parseInt(color.slice(3, 5), 16);
                                const b = parseInt(color.slice(5, 7), 16);
                                shapeElement.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                            } else {
                                shapeElement.style.backgroundColor = color;
                            }
                        } else if (shape.fillType === 'image' && shape.imageUrl) {
                            shapeElement.style.backgroundImage = `url(${shape.imageUrl})`;
                            shapeElement.style.backgroundSize = 'cover';
                            shapeElement.style.backgroundPosition = 'center';
                        } else if (shape.fillType === 'gradient' && shape.gradientColors) {
                            const colors = shape.gradientColors.map(c => {
                                const opacity = 1; // Gradient colors use their own opacity
                                if (c.color.startsWith('#')) {
                                    const r = parseInt(c.color.slice(1, 3), 16);
                                    const g = parseInt(c.color.slice(3, 5), 16);
                                    const b = parseInt(c.color.slice(5, 7), 16);
                                    return `rgba(${r}, ${g}, ${b}, ${opacity}) ${c.stop}%`;
                                }
                                return `${c.color} ${c.stop}%`;
                            }).join(', ');
                            
                            if (shape.gradientType === 'radial') {
                                shapeElement.style.background = `radial-gradient(circle, ${colors})`;
                            } else if (shape.gradientType === 'conic') {
                                shapeElement.style.background = `conic-gradient(${colors})`;
                            } else {
                                shapeElement.style.background = `linear-gradient(${shape.gradientDirection || 'to right'}, ${colors})`;
                            }
                        }
                        
                        // Set border
                        if (shape.borderWidth > 0) {
                            const borderOpacity = (shape.borderOpacity || 100) / 100;
                            const borderColor = shape.borderColor || '#000000';
                            if (borderColor.startsWith('#')) {
                                const r = parseInt(borderColor.slice(1, 3), 16);
                                const g = parseInt(borderColor.slice(3, 5), 16);
                                const b = parseInt(borderColor.slice(5, 7), 16);
                                shapeElement.style.border = `${shape.borderWidth}px solid rgba(${r}, ${g}, ${b}, ${borderOpacity})`;
                            } else {
                                shapeElement.style.border = `${shape.borderWidth}px solid ${borderColor}`;
                            }
                        }
                        
                        shapesContainer.appendChild(shapeElement);
                    });
                    
                    section.appendChild(shapesContainer);
                }
                
                // Add vertical slides if present
                if (slide.verticalSlides && slide.verticalSlides.length > 0) {
                    slide.verticalSlides.forEach((verticalSlide) => {
                        const verticalSection = document.createElement('section');
                        
                        // Ensure images and shapes arrays exist
                        if (!verticalSlide.images) {
                            verticalSlide.images = [];
                        }
                        if (!verticalSlide.shapes) {
                            verticalSlide.shapes = [];
                        }
                        
                        const verticalProps = verticalSlide.properties || {};
                        
                        if (verticalProps.transition) verticalSection.setAttribute('data-transition', verticalProps.transition);
                        if (verticalProps.background) verticalSection.setAttribute('data-background', verticalProps.background);
                        if (verticalProps.backgroundImage) verticalSection.setAttribute('data-background-image', verticalProps.backgroundImage);
                        if (verticalProps.backgroundVideo) verticalSection.setAttribute('data-background-video', verticalProps.backgroundVideo);
                        if (verticalProps.backgroundSize) verticalSection.setAttribute('data-background-size', verticalProps.backgroundSize);
                        if (verticalProps.autoAnimate) verticalSection.setAttribute('data-auto-animate', '');
                        
                        verticalSection.setAttribute('data-markdown', '');
                        
                        if (verticalSlide.notes) {
                            const verticalNotesElement = document.createElement('aside');
                            verticalNotesElement.className = 'notes';
                            verticalNotesElement.setAttribute('data-markdown', '');
                            const verticalNotesScript = document.createElement('script');
                            verticalNotesScript.type = 'text/template';
                            verticalNotesScript.textContent = verticalSlide.notes;
                            verticalNotesElement.appendChild(verticalNotesScript);
                            verticalSection.appendChild(verticalNotesElement);
                        }
                        
                        const verticalScript = document.createElement('script');
                        verticalScript.type = 'text/template';
                        verticalScript.textContent = verticalSlide.content || '';
                        verticalSection.appendChild(verticalScript);
                        
                        // Add images to vertical slide if present
                        if (verticalSlide.images && verticalSlide.images.length > 0) {
                            const imagesContainer = document.createElement('div');
                            imagesContainer.className = 'slide-images-container';
                            imagesContainer.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10;';
                            
                            verticalSlide.images.forEach((img) => {
                                const imgElement = document.createElement('img');
                                imgElement.src = img.url;
                                imgElement.style.cssText = `
                                    position: absolute;
                                    left: ${img.x}%;
                                    top: ${img.y}%;
                                    width: ${img.width}%;
                                    height: ${img.height}%;
                                    object-fit: ${img.objectFit || 'contain'};
                                    border-radius: ${img.borderRadius || 0}px;
                                    opacity: ${(img.opacity || 100) / 100};
                                    transform: translate(-50%, -50%);
                                    pointer-events: auto;
                                `;
                                
                                // Apply cropping using clip-path
                                if (img.cropX !== undefined && img.cropY !== undefined && 
                                    img.cropWidth !== undefined && img.cropHeight !== undefined &&
                                    (img.cropX !== 0 || img.cropY !== 0 || img.cropWidth !== 100 || img.cropHeight !== 100)) {
                                    const clipX = img.cropX;
                                    const clipY = img.cropY;
                                    const clipWidth = img.cropWidth;
                                    const clipHeight = img.cropHeight;
                                    imgElement.style.clipPath = `inset(${clipY}% ${100 - clipX - clipWidth}% ${100 - clipY - clipHeight}% ${clipX}%)`;
                                }
                                
                                imagesContainer.appendChild(imgElement);
                            });
                            
                            verticalSection.appendChild(imagesContainer);
                        }
                        
                        // Add shapes to vertical slide if present
                        if (verticalSlide.shapes && verticalSlide.shapes.length > 0) {
                            const shapesContainer = document.createElement('div');
                            shapesContainer.className = 'slide-shapes-container';
                            shapesContainer.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 9;';
                            
                            verticalSlide.shapes.forEach((shape) => {
                                const shapeElement = document.createElement('div');
                                shapeElement.style.cssText = `
                                    position: absolute;
                                    left: ${shape.x}%;
                                    top: ${shape.y}%;
                                    width: ${shape.width}%;
                                    height: ${shape.height}%;
                                    opacity: ${(shape.opacity || 100) / 100};
                                    transform: translate(-50%, -50%) rotate(${shape.rotation || 0}deg);
                                    pointer-events: auto;
                                `;
                                
                                // Set shape type
                                if (shape.type === 'circle' || shape.type === 'ellipse') {
                                    shapeElement.style.borderRadius = '50%';
                                } else if (shape.type === 'triangle') {
                                    shapeElement.style.width = '0';
                                    shapeElement.style.height = '0';
                                    shapeElement.style.borderLeft = `${shape.width / 2}% solid transparent`;
                                    shapeElement.style.borderRight = `${shape.width / 2}% solid transparent`;
                                    shapeElement.style.borderBottom = `${shape.height}% solid`;
                                    shapeElement.style.borderTop = 'none';
                                    shapeElement.style.background = 'none';
                                } else {
                                    shapeElement.style.borderRadius = `${shape.borderRadius || 0}px`;
                                }
                                
                                // Set fill (same logic as main slides)
                                if (shape.fillType === 'color') {
                                    const opacity = (shape.colorOpacity || 100) / 100;
                                    const color = shape.color || '#3b82f6';
                                    if (color.startsWith('#')) {
                                        const r = parseInt(color.slice(1, 3), 16);
                                        const g = parseInt(color.slice(3, 5), 16);
                                        const b = parseInt(color.slice(5, 7), 16);
                                        shapeElement.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${opacity})`;
                                    } else {
                                        shapeElement.style.backgroundColor = color;
                                    }
                                } else if (shape.fillType === 'image' && shape.imageUrl) {
                                    shapeElement.style.backgroundImage = `url(${shape.imageUrl})`;
                                    shapeElement.style.backgroundSize = 'cover';
                                    shapeElement.style.backgroundPosition = 'center';
                                } else if (shape.fillType === 'gradient' && shape.gradientColors) {
                                    const colors = shape.gradientColors.map(c => {
                                        if (c.color.startsWith('#')) {
                                            const r = parseInt(c.color.slice(1, 3), 16);
                                            const g = parseInt(c.color.slice(3, 5), 16);
                                            const b = parseInt(c.color.slice(5, 7), 16);
                                            return `rgba(${r}, ${g}, ${b}, 1) ${c.stop}%`;
                                        }
                                        return `${c.color} ${c.stop}%`;
                                    }).join(', ');
                                    
                                    if (shape.gradientType === 'radial') {
                                        shapeElement.style.background = `radial-gradient(circle, ${colors})`;
                                    } else if (shape.gradientType === 'conic') {
                                        shapeElement.style.background = `conic-gradient(${colors})`;
                                    } else {
                                        shapeElement.style.background = `linear-gradient(${shape.gradientDirection || 'to right'}, ${colors})`;
                                    }
                                }
                                
                                // Set border
                                if (shape.borderWidth > 0) {
                                    const borderOpacity = (shape.borderOpacity || 100) / 100;
                                    const borderColor = shape.borderColor || '#000000';
                                    if (borderColor.startsWith('#')) {
                                        const r = parseInt(borderColor.slice(1, 3), 16);
                                        const g = parseInt(borderColor.slice(3, 5), 16);
                                        const b = parseInt(borderColor.slice(5, 7), 16);
                                        shapeElement.style.border = `${shape.borderWidth}px solid rgba(${r}, ${g}, ${b}, ${borderOpacity})`;
                                    } else {
                                        shapeElement.style.border = `${shape.borderWidth}px solid ${borderColor}`;
                                    }
                                }
                                
                                shapesContainer.appendChild(shapeElement);
                            });
                            
                            verticalSection.appendChild(shapesContainer);
                        }
                        
                        section.appendChild(verticalSection);
                    });
                }
                
                slidesContainer.appendChild(section);
            });

            if (reveal) {
                reveal.initialize().then(() => {
                    reveal.slide(currentSlideIndex, currentVerticalIndex);
                    updateSlideContent();
                    updateSlideProperties();
                    updateImageList();
                    currentEditingImageIndex = -1;
                    document.getElementById('imageEditor').style.display = 'none';
                    updateSlideIndicator();
                }).catch((error) => {
                    console.error('Failed to reinitialize Reveal.js:', error);
                });
            } else {
                initReveal();
            }
        }

        // Add slide
        function addSlide() {
            if (!currentPresentation.slides) {
                currentPresentation.slides = [];
            }
            
            const newSlide = { 
                content: '# New Slide\n\nAdd your content here',
                notes: '',
                properties: {},
                images: [],
                shapes: []
            };
            const insertIndex = currentSlideIndex + 1;
            currentPresentation.slides.splice(insertIndex, 0, newSlide);
            loadSlidesIntoReveal(currentPresentation.slides);
            
            setTimeout(() => {
                if (reveal) {
                    reveal.slide(insertIndex);
                }
            }, 100);
        }

        // Add vertical slide
        function addVerticalSlide() {
            if (!currentPresentation.slides) {
                currentPresentation.slides = [];
            }
            
            // Find current slide and add vertical slide to it
            const currentSlide = currentPresentation.slides[currentSlideIndex];
            if (!currentSlide.verticalSlides) {
                currentSlide.verticalSlides = [];
            }
            
            const newVerticalSlide = {
                content: '# Vertical Slide\n\nSub-slide content',
                notes: '',
                properties: {},
                images: [],
                shapes: []
            };
            
            currentSlide.verticalSlides.push(newVerticalSlide);
            loadSlidesIntoReveal(currentPresentation.slides);
        }

        // Remove slide
        function removeSlide() {
            if (!currentPresentation.slides || currentPresentation.slides.length <= 1) {
                showNotification('Cannot remove the last slide', 'error');
                return;
            }
            
            const newIndex = currentSlideIndex >= currentPresentation.slides.length - 1 
                ? currentPresentation.slides.length - 2 
                : currentSlideIndex;
            
            currentPresentation.slides.splice(currentSlideIndex, 1);
            loadSlidesIntoReveal(currentPresentation.slides);
            
            setTimeout(() => {
                if (reveal) {
                    reveal.slide(Math.max(0, newIndex));
                }
            }, 100);
        }

        // Update slide
        function updateSlide() {
            // Get content from appropriate editor
            let content;
            if (editorMode === 'visual' && quillEditor) {
                // Get HTML from Quill and convert to markdown
                const html = quillEditor.root.innerHTML;
                content = htmlToMarkdown(html);
                // Also update textarea for consistency
                document.getElementById('slideContent').value = content;
            } else {
                content = document.getElementById('slideContent').value;
            }
            
            const notes = document.getElementById('slideNotes').value;
            
            if (!currentPresentation.slides) {
                currentPresentation.slides = [];
            }
            
            while (currentPresentation.slides.length <= currentSlideIndex) {
                currentPresentation.slides.push({ content: '', notes: '', properties: {}, images: [], shapes: [] });
            }
            
            // Ensure images and shapes arrays exist
            if (!currentPresentation.slides[currentSlideIndex].images) {
                currentPresentation.slides[currentSlideIndex].images = [];
            }
            if (!currentPresentation.slides[currentSlideIndex].shapes) {
                currentPresentation.slides[currentSlideIndex].shapes = [];
            }
            
            // Get properties from UI
            const bgColor = document.getElementById('slideBgColor').value || '#000000';
            const bgColorOpacity = parseFloat(document.getElementById('slideBgColorOpacity').value) || 100;
            
            // Convert hex color + opacity to rgba - ALWAYS set a background
            let backgroundValue = bgColor;
            if (bgColor && bgColor.startsWith('#')) {
                const r = parseInt(bgColor.slice(1, 3), 16);
                const g = parseInt(bgColor.slice(3, 5), 16);
                const b = parseInt(bgColor.slice(5, 7), 16);
                const a = bgColorOpacity / 100;
                // Always create rgba, even if opacity is 100%
                if (a === 1.0) {
                    backgroundValue = `rgb(${r}, ${g}, ${b})`;
                } else {
                    backgroundValue = `rgba(${r}, ${g}, ${b}, ${a})`;
                }
            }
            
            const props = {
                transition: document.getElementById('slideTransition').value || null,
                background: backgroundValue, // Always set background, even if black
                backgroundOpacity: bgColorOpacity,
                backgroundImage: document.getElementById('slideBgImage').value || null,
                backgroundVideo: document.getElementById('slideBgVideo').value || null,
                backgroundSize: document.getElementById('slideBgSize').value || null,
                autoAnimate: document.getElementById('slideAutoAnimate').checked,
                autoAnimateDuration: document.getElementById('slideAutoAnimateDuration').value || null,
                autoAnimateEasing: document.getElementById('slideAutoAnimateEasing').value || null
            };
            
            // Remove null/empty values, but KEEP background
            Object.keys(props).forEach(key => {
                if (key !== 'background' && (props[key] === null || props[key] === '')) {
                    delete props[key];
                }
            });
            
            currentPresentation.slides[currentSlideIndex].content = content;
            currentPresentation.slides[currentSlideIndex].notes = notes;
            currentPresentation.slides[currentSlideIndex].properties = props;
            
            loadSlidesIntoReveal(currentPresentation.slides);
        }

        // Update slide content in editor
        function updateSlideContent() {
            if (!currentPresentation.slides || currentPresentation.slides.length === 0) {
                document.getElementById('slideContent').value = '';
                document.getElementById('slideNotes').value = '';
                if (quillEditor) {
                    quillEditor.root.innerHTML = '';
                }
                return;
            }
            
            if (currentSlideIndex < currentPresentation.slides.length) {
                const slide = currentPresentation.slides[currentSlideIndex];
                const content = slide.content || '';
                document.getElementById('slideContent').value = content;
                document.getElementById('slideNotes').value = slide.notes || '';
                
                // Update Quill editor if in visual mode
                if (quillEditor && editorMode === 'visual') {
                    const html = markdownToQuill(content);
                    quillEditor.root.innerHTML = html;
                }
            } else {
                document.getElementById('slideContent').value = '';
                document.getElementById('slideNotes').value = '';
                if (quillEditor) {
                    quillEditor.root.innerHTML = '';
                }
            }
        }

        // Update slide properties in UI
        function updateSlideProperties() {
            if (!currentPresentation.slides || currentPresentation.slides.length === 0) {
                return;
            }
            
            if (currentSlideIndex < currentPresentation.slides.length) {
                const props = currentPresentation.slides[currentSlideIndex].properties || {};
                document.getElementById('slideTransition').value = props.transition || '';
                
                // Handle background color - extract hex from rgba if needed
                let bgColor = props.background || '#000000';
                let bgOpacity = props.backgroundOpacity || 100;
                
                if (bgColor.startsWith('rgba')) {
                    const match = bgColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
                    if (match) {
                        const r = parseInt(match[1]);
                        const g = parseInt(match[2]);
                        const b = parseInt(match[3]);
                        const a = match[4] ? parseFloat(match[4]) : 1;
                        bgColor = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
                        bgOpacity = Math.round(a * 100);
                    }
                }
                
                document.getElementById('slideBgColor').value = bgColor;
                document.getElementById('slideBgColorOpacity').value = bgOpacity;
                document.getElementById('slideBgImage').value = props.backgroundImage || '';
                document.getElementById('slideBgVideo').value = props.backgroundVideo || '';
                document.getElementById('slideBgSize').value = props.backgroundSize || '';
                document.getElementById('slideAutoAnimate').checked = props.autoAnimate || false;
                document.getElementById('slideAutoAnimateDuration').value = props.autoAnimateDuration || '1.0';
                document.getElementById('slideAutoAnimateEasing').value = props.autoAnimateEasing || 'ease';
                
                // Update preview
                updateBgColorPreview();
            }
        }

        // Update slide indicator
        function updateSlideIndicator() {
            if (!reveal) {
                document.getElementById('slideIndicator').textContent = '0 / 0';
                return;
            }
            
            try {
                const total = reveal.getTotalSlides();
                const indices = reveal.getIndices();
                const current = (indices.h || 0) + 1;
                const vertical = indices.v > 0 ? ` (${indices.v + 1})` : '';
                document.getElementById('slideIndicator').textContent = `${current}${vertical} / ${total}`;
            } catch (e) {
                console.warn('Failed to update slide indicator:', e);
                const slideCount = currentPresentation.slides ? currentPresentation.slides.length : 0;
                document.getElementById('slideIndicator').textContent = `${currentSlideIndex + 1} / ${slideCount}`;
            }
        }

        // Change theme
        function changeTheme() {
            const theme = document.getElementById('themeSelect').value;
            currentPresentation.theme = theme;
            const themeLink = document.getElementById('theme');
            themeLink.href = `https://cdn.jsdelivr.net/npm/reveal.js@4.6.1/dist/theme/${theme}.css`;
        }

        // Toggle fullscreen
        function toggleFullscreen() {
            const revealContainer = document.querySelector('.reveal-container');
            if (!document.fullscreenElement) {
                revealContainer.requestFullscreen().catch(err => {
                    showNotification('Error attempting to enable fullscreen: ' + err.message, 'error');
                });
            } else {
                document.exitFullscreen();
            }
        }

        // Save presentation
        async function savePresentation() {
            const name = document.getElementById('presentationName').value;
            const id = document.getElementById('presentationId').value;

            if (!name || !id) {
                showNotification('Presentation name and ID are required', 'error');
                return;
            }

            if (!currentPresentation.slides || currentPresentation.slides.length === 0) {
                showNotification('No slides to save', 'error');
                return;
            }

            const saveBtn = document.getElementById('saveBtn');
            const originalText = saveBtn.innerHTML;
            saveBtn.classList.add('loading');
            saveBtn.disabled = true;

            currentPresentation.name = name;
            currentPresentation.id = id;

            try {
                const response = await fetch(`${API_BASE}/api/graphics/presentations`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(currentPresentation)
                });

                if (response.ok) {
                    showNotification('Presentation saved successfully');
                    await loadPresentations();
                    document.getElementById('presentationSelect').value = id;
                } else {
                    const error = await response.text();
                    showNotification('Failed to save: ' + error, 'error');
                }
            } catch (error) {
                console.error('Failed to save presentation:', error);
                showNotification('Failed to save presentation', 'error');
            } finally {
                saveBtn.classList.remove('loading');
                saveBtn.disabled = false;
                saveBtn.innerHTML = originalText;
            }
        }

        // Export to mixer
        async function exportToMixer() {
            if (!currentPresentation.id) {
                showNotification('Please save the presentation first', 'error');
                return;
            }

            const exportBtn = document.getElementById('exportBtn');
            const originalText = exportBtn.innerHTML;
            exportBtn.classList.add('loading');
            exportBtn.disabled = true;

            try {
                const response = await fetch(`${API_BASE}/api/graphics/export/${currentPresentation.id}`, {
                    method: 'POST'
                });

                if (response.ok) {
                    showNotification('Presentation exported to mixer');
                } else {
                    const error = await response.text();
                    showNotification('Failed to export: ' + error, 'error');
                }
            } catch (error) {
                console.error('Failed to export presentation:', error);
                showNotification('Failed to export presentation', 'error');
            } finally {
                exportBtn.classList.remove('loading');
                exportBtn.disabled = false;
                exportBtn.innerHTML = originalText;
            }
        }

        // Update presentation list
        function updatePresentationList(presentations) {
            // Logic merged into handling
        }

        // Show notification
        function showNotification(message, type = 'success') {
            const notification = document.createElement('div');
            notification.className = `notification ${type === 'error' ? 'error' : ''}`;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        // Initialize on load
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Don't trigger shortcuts when typing in inputs
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.getAttribute('contenteditable') === 'true') {
                return;
            }
            
            // Ctrl+S or Cmd+S to save
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                savePresentation();
            }
            
            // F11 for fullscreen
            if (e.key === 'F11') {
                e.preventDefault();
                toggleFullscreen();
            }
        });

        window.addEventListener('load', () => {
            console.log('Page loaded, initializing graphics app...');
            if (typeof Reveal === 'undefined') {
                console.warn('Reveal.js not loaded yet, waiting...');
                setTimeout(() => {
                    if (typeof Reveal === 'undefined') {
                        console.error('Reveal.js still not loaded after timeout');
                        showNotification('Reveal.js failed to load. Please refresh the page.', 'error');
                    } else {
                        init();
                    }
                }, 1000);
            } else {
                init();
            }
        });
    </script>
</body>
</html>