<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>R58 Professional Switcher</title>
    <style>
        :root {
            /* Colors */
            --bg-dark: #0a0a0a;
            --bg-panel: #141414;
            --bg-element: #1f1f1f;
            --bg-hover: #2a2a2a;
            
            --text-primary: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.7);
            --text-muted: rgba(255, 255, 255, 0.4);
            
            --accent-primary: #3b82f6;
            --accent-primary-hover: #2563eb;
            --accent-danger: #ef4444;
            --accent-success: #10b981;
            --accent-warning: #f59e0b;
            
            --border-light: rgba(255, 255, 255, 0.1);
            --border-focus: rgba(255, 255, 255, 0.25);
            
            /* Spacing */
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 10px;
            --spacing-lg: 16px;
            
            /* UI Elements */
            --radius-sm: 4px;
            --radius-md: 6px;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.3);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
            
            /* Transitions */
            --transition-fast: 0.15s ease;
            --transition-panel: 0.3s ease-out;
            
            /* Responsive & Touch */
            --touch-target-min: 48px;
            --mobile-spacing: 12px;
            --bottom-bar-height: 64px;
            --sidebar-width: 180px;
            --header-height: 56px;
        }

        html {
            background: var(--bg-dark);
            height: 100%;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Inter', Oxygen, Ubuntu, Cantarell, sans-serif;
            background: var(--bg-dark);
            background-attachment: fixed;
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
            touch-action: manipulation;
            /* iOS safe area support */
            padding-top: env(safe-area-inset-top);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
        }

        .switcher-container {
            display: grid;
            grid-template-columns: 180px 1fr 180px;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
        }

        /* Left Sidebar */
        .left-sidebar {
            background: var(--bg-panel);
            border-right: 1px solid var(--border-light);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .sidebar-header {
            padding: var(--spacing-md);
            border-bottom: 1px solid var(--border-light);
        }

        .quick-access-toolbar {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
            padding: var(--spacing-md);
        }

        .toolbar-btn {
            width: 44px;
            height: 44px;
            background: var(--bg-element);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all var(--transition-fast);
        }

        .toolbar-btn:hover {
            background: var(--bg-hover);
            border-color: var(--border-focus);
            color: var(--text-primary);
        }

        .toolbar-btn.active {
            background: rgba(59, 130, 246, 0.15);
            border-color: var(--accent-primary);
            color: var(--accent-primary);
        }

        .system-status {
            padding: var(--spacing-sm) var(--spacing-md);
            border-top: 1px solid var(--border-light);
            border-bottom: 1px solid var(--border-light);
        }

        .status-compact {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #6b7280;
        }

        .status-dot.active {
            background: var(--accent-success);
            box-shadow: 0 0 8px rgba(16, 185, 129, 0.6);
        }

        .status-dot.error {
            background: var(--accent-danger);
            box-shadow: 0 0 8px rgba(239, 68, 68, 0.6);
        }

        .remote-indicator {
            margin-top: var(--spacing-xs);
        }

        .remote-badge {
            background: rgba(245, 158, 11, 0.2);
            border: 1px solid var(--accent-warning);
            color: var(--accent-warning);
            padding: 2px 6px;
            border-radius: var(--radius-sm);
            font-size: 9px;
            font-weight: 600;
        }

        .compact-input-grid {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
            padding: var(--spacing-md);
            overflow-y: auto;
        }

        .compact-input {
            position: relative;
            background: #000;
            border: 2px solid var(--border-light);
            border-radius: var(--radius-sm);
            overflow: hidden;
            aspect-ratio: 16/9;
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .compact-input:hover {
            border-color: var(--border-focus);
        }

        .compact-input.tally-pgm {
            border-color: var(--accent-danger);
            box-shadow: 0 0 0 2px var(--accent-danger);
        }

        .compact-input video {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .compact-input-label {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.9), transparent);
            padding: 2px 4px;
            font-size: 9px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .compact-input-status {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            font-weight: 700;
            padding: 4px 8px;
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 5;
            pointer-events: none;
        }
        
        .compact-input-status.status-connecting {
            color: var(--text-muted);
            animation: pulse 1.5s ease-in-out infinite;
        }
        
        .compact-input-status.status-reconnecting {
            background: rgba(245, 158, 11, 0.3);
            color: var(--accent-warning);
            animation: pulse 1s ease-in-out infinite;
        }
        
        .compact-input-status.status-error {
            background: rgba(239, 68, 68, 0.3);
            color: var(--accent-danger);
        }
        
        .compact-input-status.status-failed {
            background: rgba(239, 68, 68, 0.5);
            color: #fff;
        }
        
        .compact-input-status.status-unsupported {
            background: rgba(107, 114, 128, 0.5);
            color: var(--text-secondary);
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Center Area */
        .center-area {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: #000;
        }

        .preview-program-section {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: var(--spacing-md);
            padding: var(--spacing-md);
            align-items: center;
            min-height: 0;
        }

        .preview-output, .program-output {
            position: relative;
            background: #000;
            border-radius: var(--radius-md);
            overflow: hidden;
            border: 2px solid;
            aspect-ratio: 16/9;
            width: 100%;
            max-height: 100%;
        }

        .preview-output {
            border-color: var(--accent-success);
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.2);
        }

        .program-output {
            border-color: var(--accent-danger);
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.2);
        }

        .output-label {
            position: absolute;
            top: 8px;
            left: 8px;
            background: rgba(0, 0, 0, 0.85);
            padding: 4px 8px;
            border-radius: var(--radius-sm);
            font-size: 12px;
            font-weight: 700;
            letter-spacing: 1px;
            text-transform: uppercase;
            z-index: 10;
            border-left: 3px solid currentColor;
        }

        .preview-output .output-label {
            color: var(--accent-success);
        }

        .program-output .output-label {
            color: var(--accent-danger);
        }

        .output-video {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: block;
        }

        /* Preview composite container for CSS-based preview */
        .preview-composite {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
        }

        .preview-slot {
            position: absolute;
            overflow: hidden;
        }

        .preview-slot video {
            width: 100%;
            height: 100%;
            object-fit: contain; /* Changed from cover to contain to match mixer behavior */
            display: block;
            background: #000;
        }

        .output-placeholder {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.5);
            z-index: 5;
        }

        .output-placeholder .placeholder-icon {
            font-size: 48px;
            opacity: 0.3;
            margin-bottom: 16px;
        }

        .output-placeholder .placeholder-text {
            font-size: 14px;
            font-weight: 700;
            color: var(--text-muted);
            letter-spacing: 2px;
            text-align: center;
        }
        
        .output-placeholder .placeholder-subtext {
            font-size: 11px;
            color: var(--text-muted);
            opacity: 0.7;
            margin-top: 8px;
            text-align: center;
        }

        .box-overlays {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .box-overlay {
            position: absolute;
            border: 2px solid;
            border-radius: var(--radius-sm);
            z-index: 6;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 24px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(2px);
            box-sizing: border-box;
        }

        .box-overlay.has-input {
            background: rgba(0, 0, 0, 0.1);
        }

        .box-overlay.box-1 { border-color: var(--accent-primary); color: var(--accent-primary); }
        .box-overlay.box-2 { border-color: var(--accent-danger); color: var(--accent-danger); }
        .box-overlay.box-3 { border-color: var(--accent-success); color: var(--accent-success); }
        .box-overlay.box-4 { border-color: var(--accent-warning); color: var(--accent-warning); }

        .box-number {
            position: absolute;
            top: 4px;
            left: 4px;
            background: rgba(0, 0, 0, 0.8);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 700;
        }

        .box-input-label {
            position: absolute;
            bottom: 4px;
            left: 4px;
            right: 4px;
            background: rgba(0, 0, 0, 0.8);
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 600;
            text-align: center;
            text-transform: uppercase;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .take-button {
            width: 80px;
            height: 60px;
            background: var(--accent-danger);
            border: none;
            border-radius: var(--radius-md);
            color: #fff;
            font-size: 16px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all var(--transition-fast);
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
        }

        .take-button:hover {
            background: #dc2626;
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(239, 68, 68, 0.6);
        }

        .take-button:active {
            transform: scale(0.95);
        }

        .scene-buttons-section {
            padding: var(--spacing-md);
            border-top: 1px solid var(--border-light);
            overflow-y: auto;
            max-height: 40vh;
        }

        .scene-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: var(--spacing-md);
        }

        .scene-button-large {
            padding: var(--spacing-lg);
            border: 2px solid var(--border-light);
            background: var(--bg-element);
            color: var(--text-primary);
            border-radius: var(--radius-md);
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all var(--transition-fast);
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
            min-height: 90px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .scene-button-large:hover {
            background: var(--bg-hover);
            border-color: var(--border-focus);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .scene-button-large:active {
            transform: translateY(0) scale(0.98);
        }

        .scene-button-large.active {
            background: rgba(59, 130, 246, 0.15);
            border-color: var(--accent-primary);
            color: var(--accent-primary);
            box-shadow: 0 0 0 2px var(--accent-primary);
        }

        .scene-button-large.preview {
            opacity: 0.7;
            border-color: var(--accent-success);
        }

        /* Right Sidebar */
        .right-sidebar {
            background: var(--bg-panel);
            border-left: 1px solid var(--border-light);
            display: flex;
            flex-direction: column;
            padding: var(--spacing-md);
            gap: var(--spacing-md);
            overflow-y: auto;
        }

        .transition-controls {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
        }

        .transition-buttons {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
        }

        .btn-transition {
            padding: 12px;
            border: 2px solid var(--border-light);
            background: var(--bg-element);
            color: var(--text-primary);
            border-radius: var(--radius-md);
            font-size: 12px;
            font-weight: 700;
            cursor: pointer;
            transition: all var(--transition-fast);
            text-transform: uppercase;
            letter-spacing: 1px;
            min-height: 50px;
        }

        .btn-transition:hover {
            background: var(--bg-hover);
            border-color: var(--border-focus);
        }

        .btn-transition.active {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            box-shadow: var(--shadow-md);
        }

        .btn-transition.cut {
            border-color: var(--accent-danger);
            color: var(--accent-danger);
            background: rgba(239, 68, 68, 0.1);
        }

        .btn-transition.cut:hover {
            background: rgba(239, 68, 68, 0.2);
        }

        .btn-transition.cut:active {
            background: var(--accent-danger);
            color: #fff;
        }

        .mix-slider {
            width: 100%;
            height: 4px;
            background: var(--bg-element);
            border-radius: 2px;
            position: relative;
            cursor: pointer;
            margin-top: var(--spacing-sm);
        }

        .mix-slider-handle {
            width: 16px;
            height: 16px;
            background: #fff;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 0;
            transform: translate(-50%, -50%);
            box-shadow: var(--shadow-sm);
            transition: transform 0.1s;
        }

        .mix-slider-handle:active {
            transform: translate(-50%, -50%) scale(1.2);
        }

        .system-controls {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            padding: var(--spacing-sm);
            background: rgba(255, 255, 255, 0.05);
            border-radius: var(--radius-sm);
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .btn-system {
            padding: 12px 24px;
            border: none;
            border-radius: var(--radius-md);
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all var(--transition-fast);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-system.start {
            background: var(--accent-success);
            color: #fff;
        }

        .btn-system.start:hover {
            background: #059669;
        }

        .btn-system.stop {
            background: var(--accent-danger);
            color: #fff;
        }

        .btn-system.stop:hover {
            background: #dc2626;
        }

        .btn-system:active {
            transform: scale(0.95);
        }

        /* Off-Canvas Panels */
        .backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }

        .backdrop.active {
            opacity: 1;
            pointer-events: all;
        }

        .off-canvas-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 420px;
            max-width: 90vw;
            height: 100%;
            background: var(--bg-panel);
            border-left: 1px solid var(--border-light);
            z-index: 1001;
            transform: translateX(100%);
            transition: transform var(--transition-panel);
            display: flex;
            flex-direction: column;
            box-shadow: -4px 0 12px rgba(0, 0, 0, 0.5);
        }

        .off-canvas-panel.active {
            transform: translateX(0);
        }

        .off-canvas-panel.wide {
            width: 520px;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-md);
            border-bottom: 1px solid var(--border-light);
        }

        .panel-title {
            font-size: 13px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .close-panel-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 20px;
            cursor: pointer;
            padding: 4px;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--radius-sm);
            transition: background var(--transition-fast);
        }

        .close-panel-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: var(--spacing-md);
        }

        /* Queue Panel */
        .queue-list {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
        }

        .queue-item {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            padding: var(--spacing-md);
            background: var(--bg-element);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            cursor: grab;
            transition: all 0.2s;
        }

        .queue-item:hover {
            background: var(--bg-hover);
            border-color: var(--border-focus);
        }

        .queue-item.dragging {
            opacity: 0.5;
        }

        .queue-item.drag-over-top {
            border-top: 2px solid var(--accent-primary);
        }

        .queue-item.drag-over-bottom {
            border-bottom: 2px solid var(--accent-primary);
        }

        .queue-item-info {
            flex: 1;
        }

        .queue-item-name {
            font-size: 12px;
            font-weight: 600;
        }

        .queue-item-meta {
            font-size: 10px;
            color: var(--text-secondary);
        }

        /* Scene Editor Panel */
        .scene-canvas-container {
            position: relative;
            width: 100%;
            background: #000;
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            margin-bottom: var(--spacing-md);
            overflow: hidden;
            aspect-ratio: 16/9;
        }

        .scene-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: default;
        }

        .scene-slot-box {
            position: absolute;
            border: 1px solid;
            background: rgba(59, 130, 246, 0.2);
            cursor: move;
            user-select: none;
            transition: border-color 0.2s;
        }

        .scene-slot-box.selected {
            border-width: 2px;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 1px var(--accent-primary);
            z-index: 100;
        }

        .box-selector {
            display: flex;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-md);
        }

        .box-selector-btn {
            flex: 1;
            padding: 10px;
            border: 2px solid var(--border-light);
            background: var(--bg-element);
            color: var(--text-primary);
            border-radius: var(--radius-sm);
            font-size: 11px;
            font-weight: 700;
            cursor: pointer;
            transition: all var(--transition-fast);
            text-transform: uppercase;
        }

        .box-selector-btn.active {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
        }

        .input-selector {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: var(--spacing-sm);
        }

        .input-selector-btn {
            padding: 10px;
            border: 2px solid var(--border-light);
            background: var(--bg-element);
            color: var(--text-primary);
            border-radius: var(--radius-sm);
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .input-selector-btn.active {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
        }

        .preset-tabs {
            display: flex;
            gap: var(--spacing-xs);
            margin-bottom: var(--spacing-md);
        }

        .preset-tab {
            flex: 1;
            padding: 8px;
            border: 1px solid var(--border-light);
            background: var(--bg-element);
            color: var(--text-secondary);
            border-radius: var(--radius-sm);
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all var(--transition-fast);
            text-align: center;
            text-transform: uppercase;
        }

        .preset-tab:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }

        .preset-tab.active {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: #fff;
        }

        .preset-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: var(--spacing-sm);
            max-height: 200px;
            overflow-y: auto;
        }

        .preset-thumbnail {
            aspect-ratio: 16/9;
            background: var(--bg-element);
            border: 2px solid var(--border-light);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all var(--transition-fast);
            position: relative;
            overflow: hidden;
        }

        .preset-thumbnail:hover {
            border-color: var(--accent-primary);
        }

        .preset-thumbnail-label {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            padding: 4px;
            font-size: 10px;
            text-align: center;
            font-weight: 600;
        }

        /* Media Library Panel */
        .file-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: var(--spacing-sm);
        }

        .file-item {
            aspect-ratio: 16/9;
            background: var(--bg-element);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all var(--transition-fast);
            position: relative;
            overflow: hidden;
        }

        .file-item:hover {
            border-color: var(--border-focus);
        }

        /* Audio Mixer Panel */
        .audio-mixer-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 320px;
            background: var(--bg-panel);
            border-top: 1px solid var(--border-light);
            z-index: 1001;
            transform: translateY(100%);
            transition: transform var(--transition-panel);
            display: flex;
            flex-direction: column;
            box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.5);
        }

        .audio-mixer-panel.active {
            transform: translateY(0);
        }

        .audio-channels {
            display: flex;
            gap: var(--spacing-md);
            padding: var(--spacing-md);
            align-items: flex-end;
        }

        .audio-channel {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-sm);
            min-width: 60px;
        }

        .audio-label {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .audio-meter {
            width: 8px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        .audio-level {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: linear-gradient(to top, var(--accent-success) 0%, var(--accent-warning) 70%, var(--accent-danger) 100%);
            transition: height 0.1s;
            border-radius: 4px;
        }

        .audio-slider {
            width: 100%;
            height: 120px;
            background: var(--bg-element);
            border-radius: 4px;
            cursor: pointer;
            position: relative;
            margin: var(--spacing-sm) 0;
        }

        .audio-slider-handle {
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 24px;
            height: 8px;
            background: var(--accent-primary);
            border-radius: 2px;
            cursor: pointer;
            transition: transform 0.1s;
        }

        .audio-slider-handle:active {
            transform: translateX(-50%) scale(1.2);
        }

        .audio-controls {
            display: flex;
            gap: var(--spacing-xs);
            margin-top: var(--spacing-xs);
        }

        .audio-btn {
            flex: 1;
            padding: 4px 8px;
            background: var(--bg-element);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            color: var(--text-primary);
            font-size: 9px;
            font-weight: 600;
            cursor: pointer;
            transition: all var(--transition-fast);
            text-transform: uppercase;
        }

        .audio-btn:hover {
            background: var(--bg-hover);
        }

        .audio-btn.active {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
        }

        .audio-btn.mute.active {
            background: var(--accent-danger);
            border-color: var(--accent-danger);
        }

        /* Graphics Panel */
        .graphics-templates {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: var(--spacing-sm);
        }

        .template-item {
            aspect-ratio: 16/9;
            background: var(--bg-element);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .template-item:hover {
            border-color: var(--accent-primary);
        }

        /* Collapsible Sidebars */
        .sidebar-collapsed {
            width: 0;
            overflow: hidden;
            border: none;
            padding: 0;
        }
        
        /* Mobile Header */
        .mobile-header {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: var(--header-height);
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border-light);
            z-index: 100;
            align-items: center;
            padding: 0 var(--mobile-spacing);
            padding-top: env(safe-area-inset-top);
            padding-left: max(var(--mobile-spacing), env(safe-area-inset-left));
            padding-right: max(var(--mobile-spacing), env(safe-area-inset-right));
            gap: var(--mobile-spacing);
        }
        
        .mobile-header-title {
            flex: 1;
            font-size: 16px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .hamburger-btn {
            width: var(--touch-target-min);
            height: var(--touch-target-min);
            background: none;
            border: none;
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            padding: 0;
        }
        
        /* Bottom Navigation Bar */
        .bottom-nav {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: calc(var(--bottom-bar-height) + env(safe-area-inset-bottom));
            background: var(--bg-panel);
            border-top: 1px solid var(--border-light);
            z-index: 100;
            padding: var(--spacing-sm) var(--mobile-spacing);
            padding-bottom: calc(var(--spacing-sm) + env(safe-area-inset-bottom));
            padding-left: max(var(--mobile-spacing), env(safe-area-inset-left));
            padding-right: max(var(--mobile-spacing), env(safe-area-inset-right));
        }
        
        .bottom-nav-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: var(--spacing-xs);
            height: 100%;
        }
        
        .bottom-nav-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
            background: var(--bg-element);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            color: var(--text-secondary);
            font-size: 20px;
            cursor: pointer;
            transition: all var(--transition-fast);
            min-height: var(--touch-target-min);
        }
        
        .bottom-nav-btn-label {
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }
        
        .bottom-nav-btn:active {
            background: var(--bg-hover);
            transform: scale(0.95);
        }
        
        .bottom-nav-btn.active {
            background: rgba(59, 130, 246, 0.15);
            border-color: var(--accent-primary);
            color: var(--accent-primary);
        }
        
        .bottom-nav-btn.take {
            background: var(--accent-danger);
            color: #fff;
            border-color: var(--accent-danger);
            font-weight: 700;
        }
        
        /* Responsive Breakpoints */
        
        /* Desktop - slight adjustment */
        @media (max-width: 1366px) {
            .switcher-container {
                grid-template-columns: 160px 1fr 160px;
            }
        }
        
        /* Tablet Landscape (1024px and below) */
        @media (max-width: 1024px) {
            :root {
                --sidebar-width: 280px;
            }
            
            .switcher-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr auto;
            }
            
            .left-sidebar,
            .right-sidebar {
                position: fixed;
                top: 0;
                bottom: 0;
                width: var(--sidebar-width);
                z-index: 200;
                transform: translateX(-100%);
                transition: transform var(--transition-panel);
            }
            
            .left-sidebar {
                left: 0;
            }
            
            .right-sidebar {
                right: 0;
                left: auto;
                transform: translateX(100%);
            }
            
            .left-sidebar.open {
                transform: translateX(0);
            }
            
            .right-sidebar.open {
                transform: translateX(0);
            }
            
            .center-area {
                grid-column: 1;
            }
            
            .preview-program-section {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto;
                gap: var(--spacing-md);
                padding: var(--spacing-lg);
            }
            
            .take-button {
                position: fixed;
                bottom: calc(var(--bottom-bar-height) + env(safe-area-inset-bottom) + 80px);
                right: max(20px, env(safe-area-inset-right));
                width: 72px;
                height: 72px;
                border-radius: 50%;
                z-index: 50;
                box-shadow: 0 4px 16px rgba(239, 68, 68, 0.5);
                font-size: 14px;
            }
            
            .scene-buttons-section {
                max-height: none;
                padding: var(--spacing-md);
            }
            
            .scene-grid {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
                gap: var(--spacing-sm);
            }
            
            .scene-button-large {
                min-height: 80px;
                font-size: 12px;
                padding: var(--spacing-md);
            }
        }
        
        /* Mobile Landscape & Tablet Portrait (768px and below) */
        @media (max-width: 768px) {
            :root {
                --sidebar-width: 280px;
            }
            
            body {
                padding-top: calc(var(--header-height) + env(safe-area-inset-top));
                padding-bottom: calc(var(--bottom-bar-height) + env(safe-area-inset-bottom));
            }
            
            .mobile-header {
                display: flex;
            }
            
            .bottom-nav {
                display: block;
            }
            
            .switcher-container {
                height: calc(100vh - var(--header-height) - var(--bottom-bar-height) - env(safe-area-inset-top) - env(safe-area-inset-bottom));
            }
            
            .left-sidebar .quick-access-toolbar,
            .right-sidebar .transition-controls {
                display: none;
            }
            
            .preview-program-section {
                grid-template-columns: 1fr;
                grid-template-rows: 1fr;
                padding: var(--mobile-spacing);
            }
            
            .preview-output {
                display: none;
            }
            
            .take-button {
                display: none;
            }
            
            .scene-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: var(--spacing-sm);
            }
            
            .scene-button-large {
                min-height: 70px;
                font-size: 11px;
                padding: var(--spacing-sm);
            }
            
            .compact-input-grid {
                padding: var(--spacing-sm);
                gap: var(--spacing-xs);
            }
        }
        
        /* Mobile Portrait (480px and below) */
        @media (max-width: 480px) {
            .scene-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .scene-button-large {
                min-height: 64px;
                font-size: 10px;
            }
            
            .program-output {
                aspect-ratio: 16/9;
            }
            
            .output-label {
                font-size: 10px;
                padding: 3px 6px;
            }
            
            .bottom-nav-btn {
                font-size: 18px;
            }
            
            .bottom-nav-btn-label {
                font-size: 8px;
            }
        }
        
        /* Touch device optimizations */
        @media (hover: none) and (pointer: coarse) {
            .toolbar-btn,
            .scene-button-large,
            .btn-transition,
            .btn-system {
                min-height: var(--touch-target-min);
                min-width: var(--touch-target-min);
            }
            
            .toolbar-btn:hover,
            .scene-button-large:hover,
            .btn-transition:hover {
                transform: none;
            }
            
            .toolbar-btn:active,
            .scene-button-large:active,
            .btn-transition:active {
                transform: scale(0.95);
            }
        }
        
        /* Landscape orientation adjustments */
        @media (max-width: 768px) and (orientation: landscape) {
            .preview-program-section {
                padding: var(--spacing-sm);
            }
            
            .scene-buttons-section {
                padding: var(--spacing-sm);
            }
            
            .scene-grid {
                grid-template-columns: repeat(4, 1fr);
            }
            
            .scene-button-large {
                min-height: 56px;
                font-size: 10px;
            }
        }

        .sidebar-toggle {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 24px;
            height: 48px;
            background: var(--bg-panel);
            border: 1px solid var(--border-light);
            border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            transition: all var(--transition-fast);
        }

        .sidebar-toggle:hover {
            background: var(--bg-hover);
        }

        .sidebar-toggle.left {
            left: 0;
            border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
            }

        .sidebar-toggle.right {
            right: 0;
            border-radius: var(--radius-sm) 0 0 var(--radius-sm);
        }
        
        /* Toast Notifications */
        .toast-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
            pointer-events: none;
        }
        
        .toast {
            background: var(--bg-panel);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            padding: var(--spacing-md) var(--spacing-lg);
            box-shadow: var(--shadow-md);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            animation: toastSlideIn 0.3s ease-out;
            pointer-events: auto;
            max-width: 400px;
        }
        
        .toast.toast-error {
            border-color: var(--accent-danger);
            background: rgba(239, 68, 68, 0.1);
        }
        
        .toast.toast-success {
            border-color: var(--accent-success);
            background: rgba(16, 185, 129, 0.1);
        }
        
        .toast.toast-warning {
            border-color: var(--accent-warning);
            background: rgba(245, 158, 11, 0.1);
        }
        
        .toast-icon {
            font-size: 18px;
        }
        
        .toast-message {
            font-size: 13px;
            flex: 1;
        }
        
        .toast-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 4px;
            font-size: 16px;
        }
        
        .toast.toast-exit {
            animation: toastSlideOut 0.2s ease-in forwards;
        }
        
        @keyframes toastSlideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes toastSlideOut {
            from {
                opacity: 1;
                transform: translateY(0);
            }
            to {
                opacity: 0;
                transform: translateY(20px);
            }
        }
    </style>
</head>
<body>
    <!-- Mobile Header -->
    <div class="mobile-header" id="mobileHeader">
        <button class="hamburger-btn" id="hamburgerBtn">‚ò∞</button>
        <div class="mobile-header-title">R58 Switcher</div>
        <div class="status-compact">
            <div class="status-dot" id="statusDotMobile"></div>
        </div>
    </div>
    
    <div class="switcher-container">
        <!-- Left Sidebar -->
        <div class="left-sidebar" id="leftSidebar">
            <div class="sidebar-header">
                <div class="status-compact">
                    <div class="status-dot" id="statusDot"></div>
                    <span id="statusText">STOPPED</span>
                </div>
                </div>
            <div class="quick-access-toolbar">
                <button class="toolbar-btn" id="queueBtn" title="Queue (Q)">üìã</button>
                <button class="toolbar-btn" id="mediaBtn" title="Media Library (M)">üé¨</button>
                <button class="toolbar-btn" id="graphicsBtn" title="Graphics (G)">üé®</button>
                <button class="toolbar-btn" id="audioBtn" title="Audio Mixer (A)">üîä</button>
                <button class="toolbar-btn" id="settingsBtn" title="Settings">‚öôÔ∏è</button>
                <button class="toolbar-btn" id="refreshBtn" title="Refresh Streams (R)">üîÑ</button>
            </div>
            <div class="system-status">
                <div class="status-compact">
                    <div class="status-dot" id="healthDot"></div>
                    <span id="healthText">HEALTHY</span>
                </div>
                <div class="status-compact remote-indicator" id="remoteIndicator" style="display: none;">
                    <span class="remote-badge">üåê REMOTE</span>
                </div>
            </div>
            <div class="compact-input-grid" id="compactInputGrid">
                <!-- Inputs will be dynamically generated -->
                </div>
            </div>

        <!-- Center Area -->
        <div class="center-area">
            <div class="preview-program-section">
                <div class="preview-output" id="previewOutput">
                    <div class="output-label">PVW</div>
                    <video id="previewVideo" class="output-video" autoplay muted playsinline></video>
                    <div class="output-placeholder" id="previewPlaceholder">
                        <div class="placeholder-icon">üìπ</div>
                        <div class="placeholder-text">PREVIEW</div>
                        <div class="placeholder-subtext">Select a scene to preview</div>
                    </div>
                    <div class="box-overlays" id="previewBoxOverlays"></div>
                </div>
                <button class="take-button" id="takeButton">TAKE</button>
                <div class="program-output" id="programOutput">
                    <div class="output-label">PGM</div>
                    <video id="programVideo" class="output-video" autoplay muted playsinline></video>
                    <div class="output-placeholder" id="programPlaceholder">
                        <div class="placeholder-icon">üì∫</div>
                        <div class="placeholder-text">NO OUTPUT</div>
                        <div class="placeholder-subtext">Start mixer to begin</div>
                    </div>
                    <div class="box-overlays" id="programBoxOverlays"></div>
                </div>
            </div>
            <div class="scene-buttons-section">
                <div class="scene-grid" id="sceneGrid">
                    <!-- Scenes will be dynamically generated -->
        </div>
            </div>
        </div>

        <!-- Right Sidebar -->
        <div class="right-sidebar" id="rightSidebar">
            <div class="transition-controls">
                <div class="transition-buttons">
                    <button class="btn-transition cut" id="cutBtn">CUT</button>
                    <button class="btn-transition" id="autoBtn">AUTO</button>
                    <button class="btn-transition" id="mixBtn">MIX</button>
            </div>
                <div class="mix-slider" id="mixSlider">
                    <div class="mix-slider-handle" id="mixHandle"></div>
                    </div>
                        </div>
            <div class="system-controls">
                <div class="status-indicator">
                    <div class="status-dot" id="statusDotRight"></div>
                    <span id="statusTextRight">STOPPED</span>
                </div>
                <button class="btn-system start" id="startBtn">START</button>
                <button class="btn-system stop" id="stopBtn">STOP</button>
                    </div>
                </div>
            </div>

    <!-- Backdrop -->
    <div class="backdrop" id="backdrop"></div>
    
    <!-- Bottom Navigation Bar (Mobile) -->
    <div class="bottom-nav" id="bottomNav">
        <div class="bottom-nav-grid">
            <button class="bottom-nav-btn" id="bottomQueueBtn">
                <span>üìã</span>
                <span class="bottom-nav-btn-label">Queue</span>
            </button>
            <button class="bottom-nav-btn" id="bottomMediaBtn">
                <span>üé¨</span>
                <span class="bottom-nav-btn-label">Media</span>
            </button>
            <button class="bottom-nav-btn take" id="bottomTakeBtn">
                <span>TAKE</span>
            </button>
            <button class="bottom-nav-btn" id="bottomGraphicsBtn">
                <span>üé®</span>
                <span class="bottom-nav-btn-label">Graphics</span>
            </button>
            <button class="bottom-nav-btn" id="bottomSettingsBtn">
                <span>‚öôÔ∏è</span>
                <span class="bottom-nav-btn-label">Settings</span>
            </button>
        </div>
    </div>
    
    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- Off-Canvas Panels -->
    <!-- Queue Panel -->
    <div class="off-canvas-panel" id="queuePanel">
        <div class="panel-header">
            <div class="panel-title">QUEUE</div>
            <button class="close-panel-btn" onclick="closePanel()">√ó</button>
                        </div>
        <div class="panel-content">
            <div class="queue-list" id="queueList">
                <!-- Queue items will be dynamically generated -->
                            </div>
            <div style="margin-top: var(--spacing-md); padding-top: var(--spacing-md); border-top: 1px solid var(--border-light);">
                <label style="display: flex; align-items: center; gap: var(--spacing-sm); cursor: pointer;">
                    <input type="checkbox" id="autoAdvanceToggle">
                    <span style="font-size: 12px;">Auto Advance</span>
                </label>
                                </div>
                            </div>
                                    </div>

    <!-- Scene Editor Panel -->
    <div class="off-canvas-panel wide" id="sceneEditorPanel">
        <div class="panel-header">
            <div class="panel-title">SCENE EDITOR</div>
            <button class="close-panel-btn" onclick="closePanel()">√ó</button>
                                    </div>
        <div class="panel-content">
            <div style="margin-bottom: var(--spacing-md); display: flex; gap: var(--spacing-sm);">
                <button class="btn btn-primary" id="newSceneBtn">New Scene</button>
                <button class="btn btn-success" id="saveSceneBtn" style="display: none;">Save</button>
                <button class="btn btn-danger" id="cancelSceneBtn" style="display: none;">Cancel</button>
                                </div>
            <div class="scene-canvas-container" id="sceneCanvasContainer">
                <canvas class="scene-canvas" id="sceneCanvas"></canvas>
                                    </div>
            <div style="margin-top: var(--spacing-md);">
                <div style="font-size: 11px; font-weight: 600; margin-bottom: var(--spacing-sm); text-transform: uppercase;">Presets</div>
                <div class="preset-tabs" style="display: flex; gap: var(--spacing-xs); margin-bottom: var(--spacing-md);">
                    <div class="preset-tab active" data-tab="presets" onclick="switchPresetTab('presets')">Presets</div>
                    <div class="preset-tab" data-tab="art" onclick="switchPresetTab('art')">Art</div>
                    <div class="preset-tab" data-tab="copy" onclick="switchPresetTab('copy')">Copy</div>
                                        </div>
                <div class="preset-grid" id="presetGrid" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: var(--spacing-sm); margin-bottom: var(--spacing-md);">
                    <!-- Presets will be dynamically generated -->
                                    </div>
                <div style="font-size: 11px; font-weight: 600; margin-bottom: var(--spacing-sm); text-transform: uppercase;">Box Selection</div>
                <div class="box-selector" id="boxSelector">
                    <button class="box-selector-btn active" data-box="1" onclick="selectBox(1)">BOX 1</button>
                    <button class="box-selector-btn" data-box="2" onclick="selectBox(2)">BOX 2</button>
                    <button class="box-selector-btn" data-box="3" onclick="selectBox(3)">BOX 3</button>
                    <button class="box-selector-btn" data-box="4" onclick="selectBox(4)">BOX 4</button>
                                </div>
                <div style="font-size: 11px; font-weight: 600; margin: var(--spacing-md) 0 var(--spacing-sm); text-transform: uppercase;">Assign Input</div>
                <div class="input-selector" id="inputSelector">
                    <button class="input-selector-btn" data-input="none" onclick="assignInput('none')">None</button>
                    <button class="input-selector-btn" data-input="cam0" onclick="assignInput('cam0')">Input 1</button>
                    <button class="input-selector-btn" data-input="cam1" onclick="assignInput('cam1')">Input 2</button>
                    <button class="input-selector-btn" data-input="cam2" onclick="assignInput('cam2')">Input 3</button>
                    <button class="input-selector-btn" data-input="cam3" onclick="assignInput('cam3')">Input 4</button>
                    <button class="input-selector-btn" data-input="guest1" onclick="assignInput('guest1')">Guest 1</button>
                    <button class="input-selector-btn" data-input="guest2" onclick="assignInput('guest2')">Guest 2</button>
                            </div>
                        </div>
                    </div>
                </div>

    <!-- Media Library Panel -->
    <div class="off-canvas-panel" id="mediaPanel">
        <div class="panel-header">
            <div class="panel-title">MEDIA LIBRARY</div>
            <button class="close-panel-btn" onclick="closePanel()">√ó</button>
                        </div>
        <div class="panel-content">
            <div class="drop-zone" id="fileDropZone" style="padding: var(--spacing-lg); text-align: center; border: 2px dashed var(--border-light); border-radius: var(--radius-sm); margin-bottom: var(--spacing-md); cursor: pointer;">
                <div style="margin-bottom: var(--spacing-sm);">Drag & Drop Files Here</div>
                <input type="file" id="fileInput" multiple accept="video/*,image/*" style="display: none;">
                <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()">Browse Files</button>
                            </div>
            <div class="file-grid" id="filesList">
                                <!-- Files will be dynamically generated -->
                            </div>
                        </div>
                    </div>

    <!-- Audio Mixer Panel -->
    <div class="audio-mixer-panel" id="audioPanel">
        <div class="panel-header">
            <div class="panel-title">AUDIO MIXER</div>
            <button class="close-panel-btn" onclick="closePanel()">√ó</button>
                </div>
        <div class="audio-channels" id="audioChannels">
            <!-- Audio channels will be dynamically generated -->
            </div>
        </div>

    <!-- Graphics Panel -->
    <div class="off-canvas-panel" id="graphicsPanel">
        <div class="panel-header">
            <div class="panel-title">GRAPHICS</div>
            <button class="close-panel-btn" onclick="closePanel()">√ó</button>
            </div>
        <div class="panel-content">
            <div style="margin-bottom: var(--spacing-md);">
                <div style="font-size: 11px; font-weight: 600; margin-bottom: var(--spacing-sm); text-transform: uppercase;">Lower Thirds</div>
                <input type="text" id="lowerThirdLine1" placeholder="Line 1" style="width: 100%; padding: var(--spacing-sm); background: var(--bg-element); border: 1px solid var(--border-light); border-radius: var(--radius-sm); color: var(--text-primary); margin-bottom: var(--spacing-sm);">
                <input type="text" id="lowerThirdLine2" placeholder="Line 2 (optional)" style="width: 100%; padding: var(--spacing-sm); background: var(--bg-element); border: 1px solid var(--border-light); border-radius: var(--radius-sm); color: var(--text-primary); margin-bottom: var(--spacing-sm);">
                <button class="btn btn-primary" style="width: 100%;" onclick="createLowerThird()">Create Lower Third</button>
                </div>
            <div>
                <div style="font-size: 11px; font-weight: 600; margin-bottom: var(--spacing-sm); text-transform: uppercase;">Templates</div>
                <div class="graphics-templates" id="graphicsTemplates">
                    <!-- Templates will be dynamically generated -->
                </div>
            </div>
            <div style="margin-top: var(--spacing-md); padding-top: var(--spacing-md); border-top: 1px solid var(--border-light);">
                <div style="font-size: 11px; font-weight: 600; margin-bottom: var(--spacing-sm); text-transform: uppercase;">Active Graphics</div>
                <div id="activeGraphicsList">
                    <!-- Active graphics will be dynamically generated -->
                </div>
            </div>
                </div>
            </div>

    <!-- Settings Panel -->
    <div class="off-canvas-panel" id="settingsPanel">
        <div class="panel-header">
            <div class="panel-title">SETTINGS</div>
            <button class="close-panel-btn" onclick="closePanel()">√ó</button>
                </div>
        <div class="panel-content">
            <div style="margin-bottom: var(--spacing-md);">
                <div style="font-size: 11px; font-weight: 600; margin-bottom: var(--spacing-sm); text-transform: uppercase;">Keyboard Shortcuts</div>
                <div style="font-size: 11px; color: var(--text-secondary); line-height: 1.6;">
                    <div>1-8: Select scenes</div>
                    <div>Space: Take (preview to program)</div>
                    <div>Q: Queue panel</div>
                    <div>M: Media library</div>
                    <div>G: Graphics panel</div>
                    <div>A: Audio mixer</div>
                    <div>R: Refresh streams</div>
                    <div>Esc: Close panels</div>
                </div>
            </div>
            <div style="margin-bottom: var(--spacing-md); padding-top: var(--spacing-md); border-top: 1px solid var(--border-light);">
                <div style="font-size: 11px; font-weight: 600; margin-bottom: var(--spacing-sm); text-transform: uppercase;">Display Preferences</div>
                <label style="display: flex; align-items: center; gap: var(--spacing-sm); cursor: pointer; margin-bottom: var(--spacing-sm);">
                    <input type="checkbox" id="showTallyLights" checked>
                    <span style="font-size: 12px;">Show Tally Lights</span>
                </label>
                <label style="display: flex; align-items: center; gap: var(--spacing-sm); cursor: pointer;">
                    <input type="checkbox" id="showBoxOverlays" checked>
                    <span style="font-size: 12px;">Show Box Overlays</span>
                </label>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script>
        const API_BASE = window.location.origin;
        const HOSTNAME = window.location.hostname;
        
        // Detect if accessing remotely via Cloudflare Tunnel
        const IS_REMOTE = window.location.hostname.includes('itagenten.no');
        
        // HLS URL helper function
        function getHLSUrl(streamPath) {
            if (IS_REMOTE) {
                return `${API_BASE}/hls/${streamPath}/index.m3u8`;
            } else {
                return `http://${HOSTNAME}:8888/${streamPath}/index.m3u8`;
            }
        }
        
        // WebRTC configuration
        // Note: WebRTC only works for local network access (not through Cloudflare tunnel)
        const webrtcConfig = {
            enabled: !IS_REMOTE,  // Disable WebRTC for remote access
            fallbackToHLS: true,
            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        };
        
        // Log WebRTC availability and update UI
        if (IS_REMOTE) {
            console.log('Remote access detected - WebRTC disabled, using HLS');
            // Show remote indicator
            const remoteIndicator = document.getElementById('remoteIndicator');
            if (remoteIndicator) {
                remoteIndicator.style.display = 'block';
            }
        } else {
            console.log('Local access detected - WebRTC enabled for ultra-low latency');
        }
        
        // WebRTC client instances
        let webrtcClients = {};
        
        // State management - REFACTORED for proper A/B bus workflow
        let mixerState = 'NULL';
        let scenes = [];
        
        // Preview state (what's queued/selected but not live)
        let previewSceneId = null;        // Scene ID currently in preview
        let previewSceneData = null;      // Full scene definition for preview rendering
        let previewVideoInstances = {};   // HLS/WebRTC instances for preview composite
        
        // Program state (what's actually live from mixer)
        let programSceneId = null;        // Scene ID currently live in program (from mixer)
        
        // Legacy compatibility (deprecated, use previewSceneId/programSceneId instead)
        let currentScene = null;
        let currentProgramScene = null;
        let currentPreviewScene = null;
        
        let hlsInstances = {};
        let currentSceneDetails = null;
        let boxMappings = { 1: null, 2: null, 3: null, 4: null };
        let selectedBox = 1;
        let activePanel = null;
        let editingScene = null;
        let isMobileMenuOpen = false;

        // Mobile menu management
        function toggleMobileMenu() {
            const leftSidebar = document.getElementById('leftSidebar');
            const backdrop = document.getElementById('backdrop');
            
            isMobileMenuOpen = !isMobileMenuOpen;
            
            if (isMobileMenuOpen) {
                leftSidebar.classList.add('open');
                backdrop.classList.add('active');
            } else {
                leftSidebar.classList.remove('open');
                backdrop.classList.remove('active');
            }
        }
        
        function closeMobileMenu() {
            const leftSidebar = document.getElementById('leftSidebar');
            const backdrop = document.getElementById('backdrop');
            
            isMobileMenuOpen = false;
            leftSidebar.classList.remove('open');
            backdrop.classList.remove('active');
        }
        
        // Detect if we're on a mobile device
        function isMobileDevice() {
            return window.innerWidth <= 768 || 
                   ('ontouchstart' in window) || 
                   (navigator.maxTouchPoints > 0);
        }
        
        // Touch gesture detection
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;
        const minSwipeDistance = 50;
        
        function initTouchGestures() {
            const programOutput = document.getElementById('programOutput');
            if (!programOutput) return;
            
            programOutput.addEventListener('touchstart', (e) => {
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            }, { passive: true });
            
            programOutput.addEventListener('touchend', (e) => {
                touchEndX = e.changedTouches[0].screenX;
                touchEndY = e.changedTouches[0].screenY;
                handleSwipe();
            }, { passive: true });
        }
        
        function handleSwipe() {
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            
            // Check if horizontal swipe is dominant
            if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > minSwipeDistance) {
                if (deltaX > 0) {
                    // Swipe right - go to previous scene
                    navigateScene(-1);
                } else {
                    // Swipe left - go to next scene
                    navigateScene(1);
                }
            }
        }
        
        function navigateScene(direction) {
            if (!scenes || scenes.length === 0) return;
            
            // Find current scene index
            let currentIndex = scenes.findIndex(s => s.id === currentPreviewScene || s.id === currentProgramScene);
            if (currentIndex === -1) currentIndex = 0;
            
            // Calculate new index with wrapping
            let newIndex = (currentIndex + direction + scenes.length) % scenes.length;
            
            // Apply the new scene
            const newScene = scenes[newIndex];
            if (newScene) {
                applyToPreview(newScene.id);
                showToast(`Scene: ${newScene.label}`, 'info', 2000);
            }
        }

        // Initialize
        async function init() {
            await loadScenes();
            await checkMixerStatus();
            initCompactInputs();
            initAudioChannels();
            initEventListeners();
            initKeyboardShortcuts();
            initDragAndDrop();
            initTouchGestures();
            startStatusPolling();
            loadQueue();
            loadFiles();
            loadGraphicsTemplates();
            loadPresets('presets');
        }

        // Panel Management
        function openPanel(panelId) {
            if (activePanel === panelId) {
                closePanel();
                return;
            }
            closePanel();
            activePanel = panelId;
            const panel = document.getElementById(panelId);
            const backdrop = document.getElementById('backdrop');
            if (panel) {
                panel.classList.add('active');
                backdrop.classList.add('active');
                // Update toolbar button state
                document.querySelectorAll('.toolbar-btn').forEach(btn => btn.classList.remove('active'));
                const btnMap = {
                    'queuePanel': 'queueBtn',
                    'mediaPanel': 'mediaBtn',
                    'graphicsPanel': 'graphicsBtn',
                    'audioPanel': 'audioBtn',
                    'settingsPanel': 'settingsBtn'
                };
                if (btnMap[panelId]) {
                    document.getElementById(btnMap[panelId])?.classList.add('active');
                }
            }
        }

        function closePanel() {
            if (activePanel) {
                const panel = document.getElementById(activePanel);
                const backdrop = document.getElementById('backdrop');
                if (panel) panel.classList.remove('active');
                if (backdrop) backdrop.classList.remove('active');
                activePanel = null;
                document.querySelectorAll('.toolbar-btn').forEach(btn => btn.classList.remove('active'));
            }
        }

        // Keyboard Shortcuts
        function initKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Don't trigger if typing in input
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                
                // Number keys 1-8 for scenes
                if (e.key >= '1' && e.key <= '8') {
                    const index = parseInt(e.key) - 1;
                    if (scenes[index]) {
                        applyToPreview(scenes[index].id);
                    }
                }
                
                // Space for TAKE
                if (e.key === ' ') {
                    e.preventDefault();
                    takePreview();
                }
                
                // Panel shortcuts
                if (e.key === 'q' || e.key === 'Q') {
                    e.preventDefault();
                    openPanel('queuePanel');
                }
                if (e.key === 'm' || e.key === 'M') {
                    e.preventDefault();
                    openPanel('mediaPanel');
                }
                if (e.key === 'g' || e.key === 'G') {
                    e.preventDefault();
                    openPanel('graphicsPanel');
                }
                if (e.key === 'a' || e.key === 'A') {
                    e.preventDefault();
                    openPanel('audioPanel');
                }
                
                // R to refresh streams
                if (e.key === 'r' || e.key === 'R') {
                    e.preventDefault();
                    resetAllStreams();
                }
                
                // Escape to close panels
                if (e.key === 'Escape') {
                    closePanel();
                }
            });
        }

        // Event Listeners
        function initEventListeners() {
            // Hamburger menu
            document.getElementById('hamburgerBtn')?.addEventListener('click', toggleMobileMenu);
            
            // Bottom navigation buttons
            document.getElementById('bottomQueueBtn')?.addEventListener('click', () => {
                closeMobileMenu();
                openPanel('queuePanel');
            });
            document.getElementById('bottomMediaBtn')?.addEventListener('click', () => {
                closeMobileMenu();
                openPanel('mediaPanel');
            });
            document.getElementById('bottomGraphicsBtn')?.addEventListener('click', () => {
                closeMobileMenu();
                openPanel('graphicsPanel');
            });
            document.getElementById('bottomSettingsBtn')?.addEventListener('click', () => {
                closeMobileMenu();
                openPanel('settingsPanel');
            });
            document.getElementById('bottomTakeBtn')?.addEventListener('click', () => {
                closeMobileMenu();
                takePreview();
            });
            
            // Panel buttons (desktop)
            document.getElementById('queueBtn')?.addEventListener('click', () => openPanel('queuePanel'));
            document.getElementById('mediaBtn')?.addEventListener('click', () => openPanel('mediaPanel'));
            document.getElementById('graphicsBtn')?.addEventListener('click', () => openPanel('graphicsPanel'));
            document.getElementById('audioBtn')?.addEventListener('click', () => openPanel('audioPanel'));
            document.getElementById('settingsBtn')?.addEventListener('click', () => openPanel('settingsPanel'));
            document.getElementById('refreshBtn')?.addEventListener('click', resetAllStreams);
            
            // Scene editor buttons
            document.getElementById('newSceneBtn')?.addEventListener('click', () => {
                editingScene = { id: `scene_${Date.now()}`, label: 'New Scene', slots: [] };
                document.getElementById('saveSceneBtn').style.display = 'inline-block';
                document.getElementById('cancelSceneBtn').style.display = 'inline-block';
            });
            document.getElementById('saveSceneBtn')?.addEventListener('click', saveScene);
            document.getElementById('cancelSceneBtn')?.addEventListener('click', () => {
                editingScene = null;
                document.getElementById('saveSceneBtn').style.display = 'none';
                document.getElementById('cancelSceneBtn').style.display = 'none';
            });
            
            // Backdrop closes panel or mobile menu
            document.getElementById('backdrop')?.addEventListener('click', () => {
                if (isMobileMenuOpen) {
                    closeMobileMenu();
                } else {
                    closePanel();
                }
            });
            
            // System controls
            document.getElementById('startBtn')?.addEventListener('click', startMixer);
            document.getElementById('stopBtn')?.addEventListener('click', stopMixer);
            document.getElementById('takeButton')?.addEventListener('click', takePreview);
            
            // Transition buttons
            document.getElementById('cutBtn')?.addEventListener('click', () => performTransition('cut'));
            document.getElementById('autoBtn')?.addEventListener('click', () => performTransition('auto'));
            document.getElementById('mixBtn')?.addEventListener('click', () => performTransition('mix'));
            
            // Mix slider
            const slider = document.getElementById('mixSlider');
            const handle = document.getElementById('mixHandle');
            if (slider && handle) {
                let isDragging = false;
                const updateMix = (e) => {
                    const rect = slider.getBoundingClientRect();
                    const x = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
                    handle.style.left = `${x * 100}%`;
                };
                slider.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    updateMix(e);
                });
                document.addEventListener('mousemove', (e) => {
                    if (isDragging) updateMix(e);
                });
                document.addEventListener('mouseup', () => {
                    isDragging = false;
                });
            }
            
            // Auto advance toggle
            document.getElementById('autoAdvanceToggle')?.addEventListener('change', async (e) => {
                try {
                    if (e.target.checked) {
                        await fetch(`${API_BASE}/api/queue/start`, { method: 'POST' });
                    } else {
                        await fetch(`${API_BASE}/api/queue/stop`, { method: 'POST' });
                    }
                    loadQueue();
                } catch (error) {
                    console.error('Failed to toggle auto-advance:', error);
                }
            });
        }

        // Load scenes
        async function loadScenes() {
            try {
                const response = await fetch(`${API_BASE}/api/scenes`);
                if (response.status === 503) {
                    showError('Mixer is not enabled. Please enable it in config.yml');
                    return;
                }
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();
                scenes = data.scenes || [];
                renderScenes();
            } catch (error) {
                console.error('Failed to load scenes:', error);
                showError('Failed to load scenes: ' + error.message);
            }
        }

        // Render scene buttons
        function renderScenes() {
            const grid = document.getElementById('sceneGrid');
            if (!grid) return;
            grid.innerHTML = '';
            
            scenes.forEach((scene, index) => {
                const btn = document.createElement('button');
                btn.className = 'scene-button-large draggable';
                btn.draggable = true;
                btn.dataset.sceneId = scene.id;
                btn.dataset.dragType = 'scene';
                btn.dataset.dragData = JSON.stringify({ type: 'scene', sceneId: scene.id, label: scene.label || scene.id });
                btn.textContent = scene.label || scene.id;
                btn.addEventListener('click', () => selectSceneForPreview(scene.id));
                btn.addEventListener('dblclick', () => applyToProgram(scene.id));
                btn.addEventListener('dragstart', handleDragStart);
                btn.addEventListener('dragend', handleDragEnd);
                grid.appendChild(btn);
            });
            updateSceneButtons();
        }

        // Update scene button states (REFACTORED for proper A/B bus)
        function updateSceneButtons() {
            document.querySelectorAll('.scene-button-large').forEach(btn => {
                btn.classList.remove('active', 'preview');
                
                const sceneId = btn.dataset.sceneId;
                const isInProgram = sceneId === programSceneId;
                const isInPreview = sceneId === previewSceneId;
                
                // Red border if in program (live)
                if (isInProgram) {
                    btn.classList.add('active');
                }
                
                // Green border if in preview (queued)
                if (isInPreview) {
                    btn.classList.add('preview');
                }
                
                // If same scene is in both preview and program, show both styles
                // (CSS will handle this with both classes applied)
            });
        }

        // Select scene for preview (NEW - does NOT apply to mixer)
        async function selectSceneForPreview(sceneId) {
            try {
                // Fetch full scene definition
                const response = await fetch(`${API_BASE}/api/scenes/${sceneId}`);
                if (!response.ok) {
                    throw new Error(`Failed to fetch scene: ${response.status}`);
                }
                
                const sceneData = await response.json();
                
                // Update preview state
                previewSceneId = sceneId;
                previewSceneData = sceneData;
                
                // Update legacy state for compatibility
                currentPreviewScene = sceneId;
                
                // Render the scene in preview using CSS composite
                await renderPreviewComposite(sceneData);
                
                // Update UI
                updateSceneButtons();
                
                console.log(`Scene ${sceneId} loaded in preview (not applied to mixer yet)`);
            } catch (error) {
                console.error('Failed to select scene for preview:', error);
                showError('Failed to load scene: ' + error.message);
            }
        }

        // DEPRECATED: Legacy function - do not use
        // This function previously applied scenes directly to mixer
        // Use selectSceneForPreview() instead for preview-only selection
        async function applyToPreview(sceneId) {
            console.warn('applyToPreview is deprecated, use selectSceneForPreview instead');
            await selectSceneForPreview(sceneId);
        }

        // Render preview composite using CSS-positioned camera feeds
        async function renderPreviewComposite(scene) {
            const container = document.getElementById('previewOutput');
            if (!container) return;
            
            // Remove existing preview video and composite
            const oldVideo = container.querySelector('#previewVideo');
            const oldComposite = container.querySelector('.preview-composite');
            if (oldVideo) oldVideo.style.display = 'none';
            if (oldComposite) oldComposite.remove();
            
            // Hide placeholder
            const placeholder = document.getElementById('previewPlaceholder');
            if (placeholder) placeholder.style.display = 'none';
            
            // Create composite container
            const composite = document.createElement('div');
            composite.className = 'preview-composite';
            
            // Sort slots by z-order
            const sortedSlots = [...scene.slots].sort((a, b) => a.z - b.z);
            
            // Create video element for each slot
            for (const slot of sortedSlots) {
                const wrapper = document.createElement('div');
                wrapper.className = 'preview-slot';
                wrapper.style.cssText = `
                    left: ${slot.x_rel * 100}%;
                    top: ${slot.y_rel * 100}%;
                    width: ${slot.w_rel * 100}%;
                    height: ${slot.h_rel * 100}%;
                    z-index: ${slot.z};
                    opacity: ${slot.alpha};
                `;
                
                // Create video element for this slot
                const video = document.createElement('video');
                video.className = 'preview-slot-video';
                video.autoplay = true;
                video.muted = true;
                video.playsInline = true;
                
                // Load stream for this source
                const instanceId = `preview-${slot.source}`;
                
                // Check if we already have this stream in compact inputs
                const existingInput = document.querySelector(`[data-source="${slot.source}"] video`);
                if (existingInput && existingInput.srcObject) {
                    // Clone the MediaStream if available
                    video.srcObject = existingInput.srcObject;
                } else {
                    // Load new stream
                    await loadStreamForPreviewSlot(video, slot.source, instanceId);
                }
                
                wrapper.appendChild(video);
                composite.appendChild(wrapper);
            }
            
            // Add composite to container
            container.appendChild(composite);
            
            console.log(`Preview composite rendered with ${scene.slots.length} slots`);
        }

        // Load stream for a preview slot
        async function loadStreamForPreviewSlot(video, source, instanceId) {
            // Use the same loading logic as compact inputs
            const streamPath = source; // e.g., "cam0", "cam1", etc.
            
            // Store instance for cleanup
            previewVideoInstances[instanceId] = { video, source };
            
            try {
                // Load via WebRTC or HLS depending on mode
                await loadStreamWithWebRTC(video, streamPath, instanceId);
            } catch (error) {
                console.warn(`Failed to load preview stream for ${source}:`, error);
                // Show placeholder for missing stream
                video.style.background = '#1a1a1a';
            }
        }

        // Clean up preview composite
        function cleanupPreviewComposite() {
            // Cleanup all preview video instances
            Object.keys(previewVideoInstances).forEach(id => {
                if (webrtcClients[id]) {
                    cleanupWebRTCClient(id);
                }
                if (hlsInstances[id]) {
                    if (hlsInstances[id].destroy) {
                        hlsInstances[id].destroy();
                    }
                    delete hlsInstances[id];
                }
            });
            previewVideoInstances = {};
            
            // Remove composite from DOM
            const composite = document.querySelector('.preview-composite');
            if (composite) composite.remove();
            
            // Show preview video element again
            const previewVideo = document.getElementById('previewVideo');
            if (previewVideo) previewVideo.style.display = 'block';
        }

        // Apply scene directly to program (direct cut, bypasses preview)
        async function applyToProgram(sceneId) {
            try {
                // Show loading indicator
                showToast('Cutting to scene...', 'info', 0); // 0 = persistent until dismissed
                
                // Apply directly to mixer without going through preview
                const response = await fetch(`${API_BASE}/api/mixer/set_scene`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ id: sceneId })
                });
                
                if (response.ok) {
                    // Update program state
                    programSceneId = sceneId;
                    currentProgramScene = sceneId; // Legacy compatibility
                    
                    // Update UI
                    updateSceneButtons();
                    updateTallyLights();
                    await checkMixerStatus();
                    
                    console.log(`Direct CUT: Scene ${sceneId} applied to program`);
                    showToast(`Scene ${sceneId} applied (direct cut)`, 'success', 2000);
                } else {
                    const data = await response.json().catch(() => ({}));
                    showError(data.detail || 'Failed to apply scene');
                }
            } catch (error) {
                console.error('Failed to apply scene to program:', error);
                showError('Failed to apply scene: ' + error.message);
            }
        }

        // Take preview to program (REFACTORED - proper A/B bus transition)
        async function takePreview() {
            if (!previewSceneId) {
                console.warn('No scene in preview to take');
                return;
            }
            
            try {
                // Show loading indicator
                showToast('Transitioning to program...', 'info', 0); // 0 = persistent until dismissed
                
                // Apply preview scene to the mixer (this makes it live)
                const response = await fetch(`${API_BASE}/api/mixer/set_scene`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ id: previewSceneId })
                });
                
                if (response.ok) {
                    // Update program state
                    programSceneId = previewSceneId;
                    currentProgramScene = previewSceneId; // Legacy compatibility
                    
                    // Update UI
                    updateSceneButtons();
                    updateTallyLights();
                    await checkMixerStatus();
                    
                    console.log(`TAKE: Scene ${previewSceneId} is now live in program`);
                    showToast(`Scene ${previewSceneId} is now live`, 'success', 2000);
                } else {
                    const data = await response.json().catch(() => ({}));
                    showError(data.detail || 'Failed to apply scene to program');
                }
            } catch (error) {
                console.error('Failed to take preview:', error);
                showError('Failed to take preview: ' + error.message);
            }
        }

        // Initialize compact inputs
        function initCompactInputs() {
            const grid = document.getElementById('compactInputGrid');
            if (!grid) return;
            grid.innerHTML = '';

            // Camera inputs (cam0-cam3)
            for (let i = 0; i < 4; i++) {
                const input = document.createElement('div');
                input.className = 'compact-input';
                input.dataset.cameraId = `cam${i}`;
                input.innerHTML = `
                    <video id="compact-input-${i}-video" muted playsinline></video>
                    <div class="compact-input-label">Input ${i + 1}</div>
                    <div class="compact-input-status" id="compact-input-${i}-status"></div>
                `;
                input.addEventListener('click', () => selectInput(i));
                grid.appendChild(input);

                // Load preview stream with WebRTC (falls back to HLS if unavailable)
                const video = input.querySelector('video');
                if (video) {
                    loadStreamWithWebRTC(video, `cam${i}`, `compact-input-${i}`);
                }
            }
            
            // Guest inputs (guest1, guest2)
            const guests = ['guest1', 'guest2'];
            guests.forEach((guestId, idx) => {
                const inputNum = 4 + idx + 1; // Input 5, 6
                const input = document.createElement('div');
                input.className = 'compact-input guest-input';
                input.dataset.guestId = guestId;
                input.innerHTML = `
                    <video id="${guestId}-video" muted playsinline></video>
                    <div class="compact-input-label">${guestId.replace('guest', 'Guest ')}</div>
                    <div class="compact-input-status" id="${guestId}-status">Waiting...</div>
                `;
                input.addEventListener('click', () => selectGuestInput(guestId));
                grid.appendChild(input);

                // Try to load guest stream (will show waiting if not connected)
                const video = input.querySelector('video');
                if (video) {
                    loadStreamWithWebRTC(video, guestId, guestId);
                }
            });
        }
        
        // Select guest input
        function selectGuestInput(guestId) {
            console.log('Selected guest input:', guestId);
            // Could be used for assignment to scene slots
        }

        // Load preview stream
        async function loadPreviewStream() {
            if (currentPreviewScene && mixerState === 'PLAYING') {
                // Preview is handled by mixer, but we can show preview scene overlays
                fetchSceneDetails(currentPreviewScene).then(() => {
                    if (currentSceneDetails) {
                        renderPreviewBoxOverlays();
                    }
                });
            }
        }

        function renderPreviewBoxOverlays() {
            if (!currentSceneDetails || !currentSceneDetails.slots) return;
            const previewOverlays = document.getElementById('previewBoxOverlays');
            if (!previewOverlays) return;
            
            previewOverlays.innerHTML = '';
            currentSceneDetails.slots.forEach((slot, index) => {
                const coords = getSlotCoords(slot);
                const box = document.createElement('div');
                box.className = `box-overlay box-${index + 1}`;
                if (slot.source) {
                    box.classList.add('has-input');
                }
                box.style.left = `${coords.x * 100}%`;
                box.style.top = `${coords.y * 100}%`;
                box.style.width = `${coords.w * 100}%`;
                box.style.height = `${coords.h * 100}%`;
                
                const number = document.createElement('div');
                number.className = 'box-number';
                number.textContent = index + 1;
                box.appendChild(number);
                
                if (slot.source) {
                    const label = document.createElement('div');
                    label.className = 'box-input-label';
                    label.textContent = slot.source.toUpperCase();
                    box.appendChild(label);
                }
                
                previewOverlays.appendChild(box);
            });
        }

        // Update tally lights
        // Update tally lights (REFACTORED for proper A/B bus)
        function updateTallyLights() {
            document.querySelectorAll('.compact-input').forEach(input => {
                input.classList.remove('tally-pgm', 'tally-pvw');
                const camId = input.dataset.cameraId;
                
                // Check if camera is in preview scene
                if (previewSceneData && previewSceneData.slots) {
                    const isInPreview = previewSceneData.slots.some(slot => slot.source === camId);
                    if (isInPreview) {
                        input.classList.add('tally-pvw'); // Green tally
                    }
                }
                
                // Check if camera is in program scene (overrides preview if both)
                if (currentSceneDetails && currentSceneDetails.slots) {
                    const isInProgram = currentSceneDetails.slots.some(slot => slot.source === camId);
                    if (isInProgram && programSceneId) {
                        input.classList.add('tally-pgm'); // Red tally (higher priority)
                    }
                }
            });
        }

        // Initialize audio channels
        function initAudioChannels() {
            const container = document.getElementById('audioChannels');
            if (!container) return;
            container.innerHTML = '';

            for (let i = 0; i < 4; i++) {
                const channel = document.createElement('div');
                channel.className = 'audio-channel';
                channel.innerHTML = `
                    <div class="audio-label">Input ${i + 1}</div>
                    <div class="audio-meter">
                        <div class="audio-level" id="audio-${i}-level" style="height: 0%"></div>
                    </div>
                    <div class="audio-slider" id="audio-slider-${i}">
                        <div class="audio-slider-handle" id="audio-handle-${i}" style="bottom: 50%;"></div>
                    </div>
                    <div class="audio-controls">
                        <button class="audio-btn mute" id="audio-mute-${i}" onclick="toggleMute(${i})">M</button>
                        <button class="audio-btn solo" id="audio-solo-${i}" onclick="toggleSolo(${i})">S</button>
                    </div>
                `;
                container.appendChild(channel);

                // Initialize slider
                const slider = document.getElementById(`audio-slider-${i}`);
                const handle = document.getElementById(`audio-handle-${i}`);
            if (slider && handle) {
                let isDragging = false;
                    const updateVolume = (e) => {
                    const rect = slider.getBoundingClientRect();
                        const y = Math.max(0, Math.min(1, 1 - (e.clientY - rect.top) / rect.height));
                        handle.style.bottom = `${y * 100}%`;
                };
                slider.addEventListener('mousedown', (e) => {
                    isDragging = true;
                        updateVolume(e);
                });
                document.addEventListener('mousemove', (e) => {
                        if (isDragging) updateVolume(e);
                });
                document.addEventListener('mouseup', () => {
                    isDragging = false;
                });
            }
            }
        }

        // Check mixer status
        async function checkMixerStatus() {
            try {
                const response = await fetch(`${API_BASE}/api/mixer/status`);
                if (response.status === 503) {
                    updateStatus({ state: 'DISABLED', health: 'unhealthy' });
                    return;
                }
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();
                updateStatus(data);
            } catch (error) {
                if (error.message && !error.message.includes('Failed to fetch')) {
                console.error('Failed to check mixer status:', error);
                }
                updateStatus({ state: 'ERROR', health: 'unhealthy' });
            }
        }

        // Update status (REFACTORED to track program scene)
        function updateStatus(data) {
            mixerState = data.state || 'NULL';
            currentScene = data.current_scene || null;
            
            // Update program scene from mixer (what's actually live)
            if (data.current_scene) {
                programSceneId = data.current_scene;
                currentProgramScene = data.current_scene; // Legacy compatibility
                
                // Fetch scene details for tally lights
                fetchSceneDetails(data.current_scene);
            }

            // Update all status dots
            const statusDot = document.getElementById('statusDot');
            const statusDotRight = document.getElementById('statusDotRight');
            const statusDotMobile = document.getElementById('statusDotMobile');
            const healthDot = document.getElementById('healthDot');
            
            [statusDot, statusDotRight, statusDotMobile].forEach(dot => {
                if (!dot) return;
                dot.className = 'status-dot';
                if (data.state === 'PLAYING') {
                    dot.classList.add('active');
                } else if (data.state === 'DISABLED' || data.last_error) {
                    dot.classList.add('error');
                }
            });
            
            // Update health dot separately
            if (healthDot) {
                healthDot.className = 'status-dot';
                if (data.health === 'healthy') {
                    healthDot.classList.add('active');
                } else if (data.health === 'unhealthy') {
                    healthDot.classList.add('error');
                }
            }
            
            // Update text labels
            const statusText = document.getElementById('statusText');
            const statusTextRight = document.getElementById('statusTextRight');
            const healthText = document.getElementById('healthText');
            
            [statusText, statusTextRight].forEach(text => {
                if (!text) return;
                if (data.state === 'PLAYING') {
                    text.textContent = 'PLAYING';
                } else if (data.state === 'NULL') {
                    text.textContent = 'STOPPED';
                } else if (data.state === 'DISABLED') {
                    text.textContent = 'DISABLED';
                } else {
                    text.textContent = data.state || 'UNKNOWN';
                }
            });
            
            if (healthText) {
                healthText.textContent = data.health === 'healthy' ? 'HEALTHY' : 'UNHEALTHY';
            }

            // Update program output
            if (data.state === 'PLAYING' && data.mediamtx_enabled) {
                updateProgramOutput(data);
                document.getElementById('programPlaceholder')?.style.setProperty('display', 'none');
            } else {
                clearOutputs();
            }

            updateSceneButtons();
            
            // Update current scene if changed
            if (currentScene && currentScene !== currentProgramScene) {
                fetchSceneDetails(currentScene);
                currentProgramScene = currentScene;
            }
            
            // Update button states based on mixer state
            const startBtn = document.getElementById('startBtn');
            const stopBtn = document.getElementById('stopBtn');
            if (startBtn && stopBtn) {
                startBtn.disabled = data.state === 'PLAYING';
                stopBtn.disabled = data.state !== 'PLAYING';
                startBtn.style.opacity = data.state === 'PLAYING' ? '0.5' : '1';
                stopBtn.style.opacity = data.state !== 'PLAYING' ? '0.5' : '1';
            }
        }

        // Update program output
        function updateProgramOutput(data) {
            if (data.state === 'PLAYING' && data.mediamtx_enabled) {
                const video = document.getElementById('programVideo');
                const placeholder = document.getElementById('programPlaceholder');
                
                if (video && placeholder) {
                    // Only load if not already loaded (check both WebRTC and HLS)
                    const isLoaded = webrtcClients['program'] || hlsInstances['program'];
                    if (!isLoaded) {
                        placeholder.style.display = 'none';
                        loadStreamWithWebRTC(video, 'mixer_program', 'program');
                    }
                }
                
                // Also update preview if we have a preview scene
                if (currentPreviewScene && currentPreviewScene !== currentProgramScene) {
                    loadPreviewStream();
                }
            }
        }
        
        // Reset stream connections (useful for manual refresh)
        function resetAllStreams() {
            showToast('Refreshing streams...', 'info', 2000);
            
            // Cleanup WebRTC clients
            cleanupAllWebRTCClients();
            
            // Clear all HLS instances
            Object.keys(hlsInstances).forEach(id => {
                if (hlsInstances[id] && hlsInstances[id].destroy) {
                    hlsInstances[id].destroy();
                }
                delete hlsInstances[id];
            });
            
            // Clear retry state
            Object.keys(hlsRetryState).forEach(id => {
                if (hlsRetryState[id].timeout) {
                    clearTimeout(hlsRetryState[id].timeout);
                }
                delete hlsRetryState[id];
            });
            
            // Reinitialize inputs
            initCompactInputs();
            
            // Reload program output if mixer is playing
            checkMixerStatus();
        }

        // Clear outputs
        function clearOutputs() {
            const placeholders = document.querySelectorAll('.output-placeholder');
            placeholders.forEach(p => p.style.display = 'flex');
        }

        // HLS reconnection state
        const hlsRetryState = {};
        const HLS_MAX_RETRIES = 5;
        const HLS_RETRY_DELAY_BASE = 2000; // 2 seconds base delay
        
        // Load HLS stream with robust error handling and reconnection
        function loadHLS(video, url, id) {
            // Initialize retry state
            if (!hlsRetryState[id]) {
                hlsRetryState[id] = { retries: 0, timeout: null };
            }
            
            // Update status indicator
            updateStreamStatus(id, 'connecting');
            
            if (Hls.isSupported()) {
                if (hlsInstances[id]) {
                    hlsInstances[id].destroy();
                }
                
                // Configure HLS.js for remote/high-latency connections
                const hlsConfig = IS_REMOTE ? {
                    // Remote access - more tolerant of high latency
                    manifestLoadingTimeOut: 30000,      // 30s for manifest (Cloudflare can be slow)
                    manifestLoadingMaxRetry: 5,         // More retries
                    levelLoadingTimeOut: 30000,         // 30s for level loading
                    levelLoadingMaxRetry: 5,
                    fragLoadingTimeOut: 60000,          // 60s for fragment loading
                    fragLoadingMaxRetry: 4,
                    enableWorker: true,
                    lowLatencyMode: false,              // Disable LL-HLS for stability
                    backBufferLength: 60,               // Keep 60s in buffer
                    maxBufferLength: 60,                // Buffer up to 60s ahead
                    maxMaxBufferLength: 120,            // Allow up to 120s buffer
                    liveSyncDurationCount: 4,           // Sync 4 segments behind live
                    liveMaxLatencyDurationCount: 10,    // Allow up to 10 segments latency
                    startLevel: -1,                     // Auto quality selection
                    debug: false,
                } : {
                    // Local access - lower latency settings
                    manifestLoadingTimeOut: 10000,
                    manifestLoadingMaxRetry: 3,
                    levelLoadingTimeOut: 10000,
                    fragLoadingTimeOut: 20000,
                    enableWorker: true,
                    lowLatencyMode: true,               // Enable LL-HLS for local
                    backBufferLength: 30,
                    maxBufferLength: 30,
                    liveSyncDurationCount: 2,           // Closer to live edge
                    debug: false,
                };
                
                const hls = new Hls(hlsConfig);
                
                hls.loadSource(url);
                hls.attachMedia(video);
                hlsInstances[id] = hls;
                
                // Handle successful load
                hls.on(Hls.Events.MANIFEST_PARSED, () => {
                    hlsRetryState[id].retries = 0;
                    updateStreamStatus(id, 'connected');
                    video.play().catch(e => console.debug('Autoplay blocked:', e));
                });
                
                // Handle media attached
                hls.on(Hls.Events.MEDIA_ATTACHED, () => {
                    console.debug(`HLS media attached: ${id}`);
                });
                
                // Handle fragment loaded
                hls.on(Hls.Events.FRAG_LOADED, () => {
                    hlsRetryState[id].retries = 0;
                    updateStreamStatus(id, 'connected');
                });
                
                // Handle errors with reconnection logic
                hls.on(Hls.Events.ERROR, (event, data) => {
                    console.warn(`HLS error on ${id}:`, data.type, data.details);
                    
                    if (data.fatal) {
                        updateStreamStatus(id, 'error');
                        
                        switch (data.type) {
                            case Hls.ErrorTypes.NETWORK_ERROR:
                                console.warn(`HLS network error on ${id}, attempting recovery...`);
                                scheduleHLSRetry(video, url, id);
                                break;
                            case Hls.ErrorTypes.MEDIA_ERROR:
                                console.warn(`HLS media error on ${id}, attempting recovery...`);
                                hls.recoverMediaError();
                                break;
                            default:
                                console.error(`HLS fatal error on ${id}, scheduling retry...`);
                                scheduleHLSRetry(video, url, id);
                                break;
                        }
                    }
                });
                
            } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                // Native HLS support (Safari)
                video.src = url;
                video.addEventListener('loadeddata', () => {
                    updateStreamStatus(id, 'connected');
                });
                video.addEventListener('error', () => {
                    updateStreamStatus(id, 'error');
                    scheduleHLSRetry(video, url, id);
                });
            } else {
                console.error('HLS not supported on this browser');
                updateStreamStatus(id, 'unsupported');
            }
        }
        
        // Schedule HLS retry with exponential backoff
        function scheduleHLSRetry(video, url, id) {
            const state = hlsRetryState[id];
            
            // Clear existing timeout
            if (state.timeout) {
                clearTimeout(state.timeout);
            }
            
            // Check max retries
            if (state.retries >= HLS_MAX_RETRIES) {
                console.error(`HLS max retries reached for ${id}`);
                updateStreamStatus(id, 'failed');
                return;
            }
            
            // Calculate delay with exponential backoff
            const delay = HLS_RETRY_DELAY_BASE * Math.pow(2, state.retries);
            state.retries++;
            
            console.log(`Scheduling HLS retry for ${id} in ${delay}ms (attempt ${state.retries}/${HLS_MAX_RETRIES})`);
            updateStreamStatus(id, 'reconnecting', state.retries);
            
            state.timeout = setTimeout(() => {
                loadHLS(video, url, id);
            }, delay);
        }
        
        // Update stream status indicator
        function updateStreamStatus(id, status, retryCount) {
            const statusEl = document.getElementById(`${id}-status`);
            if (!statusEl) return;
            
            statusEl.className = 'compact-input-status';
            
            switch (status) {
                case 'connecting':
                    statusEl.classList.add('status-connecting');
                    statusEl.textContent = '...';
                    break;
                case 'connected':
                    statusEl.classList.add('status-connected');
                    statusEl.textContent = '';
                    statusEl.style.display = 'none';
                    break;
                case 'reconnecting':
                    statusEl.style.display = 'flex';
                    statusEl.classList.add('status-reconnecting');
                    statusEl.textContent = `‚Üª ${retryCount || ''}`;
                    break;
                case 'error':
                    statusEl.style.display = 'flex';
                    statusEl.classList.add('status-error');
                    statusEl.textContent = '‚ö†';
                    break;
                case 'failed':
                    statusEl.style.display = 'flex';
                    statusEl.classList.add('status-failed');
                    statusEl.textContent = '‚úï';
                    break;
                case 'unsupported':
                    statusEl.style.display = 'flex';
                    statusEl.classList.add('status-unsupported');
                    statusEl.textContent = '?';
                    break;
            }
        }
        
        // ========== WebRTC Stream Management ==========
        
        // Get WHEP URL for WebRTC playback
        function getWHEPUrl(streamPath) {
            // WebRTC only works for direct access to MediaMTX (not through Cloudflare proxy)
            // Always use direct connection to port 8889
            return `http://${HOSTNAME}:8889/${streamPath}/whep`;
        }
        
        // Native WHEP client implementation
        async function connectWHEP(whepUrl, iceServers) {
            const pc = new RTCPeerConnection({
                iceServers: iceServers || [{ urls: 'stun:stun.l.google.com:19302' }]
            });
            
            // Add transceivers for receiving video and audio
            pc.addTransceiver('video', { direction: 'recvonly' });
            pc.addTransceiver('audio', { direction: 'recvonly' });
            
            // Create offer
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            
            // Send offer to WHEP endpoint
            const response = await fetch(whepUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/sdp'
                },
                body: offer.sdp
            });
            
            if (!response.ok) {
                throw new Error(`WHEP endpoint returned ${response.status}: ${response.statusText}`);
            }
            
            // Get answer from server
            const answerSdp = await response.text();
            await pc.setRemoteDescription({
                type: 'answer',
                sdp: answerSdp
            });
            
            // Create media stream from received tracks
            const stream = new MediaStream();
            pc.getReceivers().forEach(receiver => {
                if (receiver.track) {
                    stream.addTrack(receiver.track);
                }
            });
            
            return { pc, stream };
        }
        
        // Load stream with WebRTC (primary) and HLS (fallback)
        async function loadStreamWithWebRTC(videoElement, streamPath, instanceId) {
            if (!videoElement) {
                console.error(`Video element not found for ${instanceId}`);
                return;
            }
            
            updateStreamStatus(instanceId, 'connecting');
            
            // Try WebRTC first
            if (webrtcConfig.enabled) {
                try {
                    console.log(`Attempting WebRTC connection for ${streamPath}...`);
                    const whepUrl = getWHEPUrl(streamPath);
                    
                    // Connect using native WHEP implementation
                    const { pc, stream } = await connectWHEP(whepUrl, webrtcConfig.iceServers);
                    
                    // Attach stream to video element
                    videoElement.srcObject = stream;
                    
                    // Store peer connection for cleanup
                    webrtcClients[instanceId] = {
                        pc: pc,
                        stream: stream,
                        type: 'webrtc',
                        streamPath: streamPath
                    };
                    
                    // Wait for video to start playing
                    await videoElement.play().catch(e => console.debug('Autoplay blocked:', e));
                    
                    updateStreamStatus(instanceId, 'connected');
                    console.log(`‚úì WebRTC connected for ${streamPath} (${instanceId})`);
                    return true;
                    
                } catch (error) {
                    console.warn(`WebRTC failed for ${streamPath}:`, error.message);
                    
                    // Cleanup failed WebRTC attempt
                    if (webrtcClients[instanceId]) {
                        try {
                            webrtcClients[instanceId].client?.disconnect();
                        } catch (e) {}
                        delete webrtcClients[instanceId];
                    }
                    
                    // Clear srcObject
                    if (videoElement.srcObject) {
                        videoElement.srcObject = null;
                    }
                }
            }
            
            // Fallback to HLS
            if (webrtcConfig.fallbackToHLS) {
                console.log(`Falling back to HLS for ${streamPath}...`);
                const hlsUrl = getHLSUrl(streamPath);
                loadHLS(videoElement, hlsUrl, instanceId);
            } else {
                updateStreamStatus(instanceId, 'failed');
            }
        }
        
        // Cleanup WebRTC client
        function cleanupWebRTCClient(instanceId) {
            if (webrtcClients[instanceId]) {
                try {
                    console.log(`Cleaning up WebRTC client: ${instanceId}`);
                    const { pc, stream, type } = webrtcClients[instanceId];
                    
                    if (type === 'webrtc') {
                        // Stop all tracks
                        if (stream) {
                            stream.getTracks().forEach(track => track.stop());
                        }
                        // Close peer connection
                        if (pc) {
                            pc.close();
                        }
                    }
                } catch (e) {
                    console.warn(`Error disconnecting WebRTC client ${instanceId}:`, e);
                }
                delete webrtcClients[instanceId];
            }
        }
        
        // Cleanup all WebRTC clients
        function cleanupAllWebRTCClients() {
            console.log('Cleaning up all WebRTC clients...');
            Object.keys(webrtcClients).forEach(id => {
                cleanupWebRTCClient(id);
            });
        }

        // Fetch scene details
        async function fetchSceneDetails(sceneId) {
            try {
                const response = await fetch(`${API_BASE}/api/scenes/${sceneId}`);
                if (response.ok) {
                    currentSceneDetails = await response.json();
                renderBoxOverlays();
                    updateTallyLights();
                }
            } catch (error) {
                console.error('Failed to fetch scene details:', error);
            }
        }

        // Helper to get slot coordinates (handles both x_rel/y_rel and x/y formats)
        function getSlotCoords(slot) {
            return {
                x: slot.x_rel !== undefined ? slot.x_rel : (slot.x || 0),
                y: slot.y_rel !== undefined ? slot.y_rel : (slot.y || 0),
                w: slot.w_rel !== undefined ? slot.w_rel : (slot.w || 1),
                h: slot.h_rel !== undefined ? slot.h_rel : (slot.h || 1)
            };
        }
        
        // Render box overlays
        function renderBoxOverlays() {
            if (!currentSceneDetails || !currentSceneDetails.slots) return;
            
            const programOverlays = document.getElementById('programBoxOverlays');
            const previewOverlays = document.getElementById('previewBoxOverlays');
            
            [programOverlays, previewOverlays].forEach(container => {
                if (!container) return;
                container.innerHTML = '';
                
                currentSceneDetails.slots.forEach((slot, index) => {
                    const coords = getSlotCoords(slot);
                    const box = document.createElement('div');
                    box.className = `box-overlay box-${index + 1}`;
                    if (slot.source) {
                        box.classList.add('has-input');
                    }
                    box.style.left = `${coords.x * 100}%`;
                    box.style.top = `${coords.y * 100}%`;
                    box.style.width = `${coords.w * 100}%`;
                    box.style.height = `${coords.h * 100}%`;
                    
                    const number = document.createElement('div');
                    number.className = 'box-number';
                    number.textContent = index + 1;
                    box.appendChild(number);
                    
                    if (slot.source) {
                        const label = document.createElement('div');
                        label.className = 'box-input-label';
                        label.textContent = slot.source.toUpperCase();
                        box.appendChild(label);
                    }
                    
                    container.appendChild(box);
                });
            });
        }

        // Start mixer
        async function startMixer() {
            try {
                const response = await fetch(`${API_BASE}/api/mixer/start`, { method: 'POST' });
                if (response.ok) {
                    showSuccess('Mixer started');
                    await checkMixerStatus();
                } else {
                    const data = await response.json().catch(() => ({}));
                    showError(data.detail || 'Failed to start mixer');
                }
            } catch (error) {
                console.error('Failed to start mixer:', error);
                showError('Failed to start mixer: ' + error.message);
            }
        }

        // Stop mixer
        async function stopMixer() {
            try {
                const response = await fetch(`${API_BASE}/api/mixer/stop`, { method: 'POST' });
                if (response.ok) {
                    showSuccess('Mixer stopped');
                    await checkMixerStatus();
                } else {
                    const data = await response.json().catch(() => ({}));
                    showError(data.detail || 'Failed to stop mixer');
                }
            } catch (error) {
                console.error('Failed to stop mixer:', error);
                showError('Failed to stop mixer: ' + error.message);
            }
        }

        // Perform transition
        function performTransition(type) {
            // Transition logic here
            document.querySelectorAll('.btn-transition').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`${type}Btn`)?.classList.add('active');
        }

        // Select input
        function selectInput(index) {
            // Input selection logic
            console.log('Selected input:', index);
        }

        // Drag and Drop
        function initDragAndDrop() {
            // Initialize drag and drop for scenes and queue
            const queueList = document.getElementById('queueList');
            if (queueList) {
                queueList.addEventListener('dragover', handleQueueDragOver);
                queueList.addEventListener('drop', handleQueueDrop);
                    }
                    
            // File drop zone
            const dropZone = document.getElementById('fileDropZone');
            if (dropZone) {
                dropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    dropZone.style.borderColor = 'var(--accent-primary)';
                    dropZone.style.background = 'rgba(59, 130, 246, 0.1)';
                });
                dropZone.addEventListener('dragleave', (e) => {
                    dropZone.style.borderColor = 'var(--border-light)';
                    dropZone.style.background = 'transparent';
                });
                dropZone.addEventListener('drop', handleFileDrop);
            }
            
            // File input
            const fileInput = document.getElementById('fileInput');
            if (fileInput) {
                fileInput.addEventListener('change', handleFileSelect);
            }
        }

        function handleDragStart(e) {
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', e.target.dataset.dragData || '');
            e.target.classList.add('dragging');
                    }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            document.querySelectorAll('.queue-item').forEach(item => {
                item.classList.remove('drag-over-top', 'drag-over-bottom');
            });
        }

        function handleQueueDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            const item = e.target.closest('.queue-item');
            if (item) {
                const rect = item.getBoundingClientRect();
                const relY = e.clientY - rect.top;
                item.classList.remove('drag-over-top', 'drag-over-bottom');
                if (relY > rect.height / 2) {
                    item.classList.add('drag-over-bottom');
                } else {
                    item.classList.add('drag-over-top');
        }
            }
        }

        async function handleQueueDrop(e) {
            e.preventDefault();
            const targetItem = e.target.closest('.queue-item');
            const dragDataStr = e.dataTransfer.getData('text/plain');
            if (!dragDataStr) return;
            const dragData = JSON.parse(dragDataStr);
            
            if (dragData.type === 'queue-item') {
                // Reordering
                const sourceIndex = dragData.index;
                let targetIndex = parseInt(targetItem?.dataset.queueIndex || 0);
                if (targetItem) {
                    const rect = targetItem.getBoundingClientRect();
                    const relY = e.clientY - rect.top;
                    if (relY > rect.height / 2) targetIndex++;
                }
                
                if (sourceIndex !== targetIndex) {
                    try {
                        const response = await fetch(`${API_BASE}/api/queue/reorder`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ indices: [sourceIndex, targetIndex] })
                        });
                        if (response.ok) await loadQueue();
            } catch (error) {
                        console.error('Failed to reorder queue:', error);
                    }
                }
            } else if (dragData.type === 'scene') {
                await addToQueue(dragData.sceneId, 10, 'cut');
            }
            
            document.querySelectorAll('.queue-item').forEach(item => {
                item.classList.remove('drag-over-top', 'drag-over-bottom');
            });
        }

        function handleFileDrop(e) {
            e.preventDefault();
            const dropZone = document.getElementById('fileDropZone');
            dropZone.style.borderColor = 'var(--border-light)';
            dropZone.style.background = 'transparent';
            
            const files = Array.from(e.dataTransfer.files);
            files.forEach(file => uploadFile(file));
            }

        function handleFileSelect(e) {
            const files = Array.from(e.target.files);
            files.forEach(file => uploadFile(file));
            }

        async function uploadFile(file) {
            const formData = new FormData();
            formData.append('file', file);
            formData.append('loop', false);
            
            try {
                const response = await fetch(`${API_BASE}/api/files/upload`, {
                    method: 'POST',
                    body: formData
                });
                if (response.ok) {
                    await loadFiles();
                }
            } catch (error) {
                console.error('Failed to upload file:', error);
            }
        }

        // Queue functions
        async function loadQueue() {
            try {
                const response = await fetch(`${API_BASE}/api/queue`);
                if (response.ok) {
                    const data = await response.json();
                    renderQueue(data.queue || []);
                }
            } catch (error) {
                console.error('Failed to load queue:', error);
            }
        }

        function renderQueue(queue) {
            const list = document.getElementById('queueList');
            if (!list) return;
            list.innerHTML = '';
            
            if (queue.length === 0) {
                list.innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: var(--spacing-lg);">Queue is empty</div>';
                    return;
                }
                
            queue.forEach((item, index) => {
                const queueItem = document.createElement('div');
                queueItem.className = 'queue-item';
                queueItem.draggable = true;
                queueItem.dataset.queueIndex = index;
                queueItem.dataset.dragData = JSON.stringify({ type: 'queue-item', index });
                queueItem.innerHTML = `
                        <div class="queue-item-info">
                        <div class="queue-item-name">${item.scene_id}</div>
                        <div class="queue-item-meta">${item.duration}s ‚Ä¢ ${item.transition}</div>
                        </div>
                    <button class="btn btn-danger btn-sm" onclick="removeFromQueue(${index})" style="padding: 4px 8px; font-size: 10px;">√ó</button>
                `;
                queueItem.addEventListener('dragstart', (e) => {
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', queueItem.dataset.dragData);
                    queueItem.classList.add('dragging');
                });
                queueItem.addEventListener('dragend', handleDragEnd);
                list.appendChild(queueItem);
            });
        }

        async function removeFromQueue(index) {
            try {
                const response = await fetch(`${API_BASE}/api/queue/${index}`, { method: 'DELETE' });
                if (response.ok) {
                    await loadQueue();
                }
            } catch (error) {
                console.error('Failed to remove from queue:', error);
            }
        }

        async function addToQueue(sceneId, duration, transition) {
            try {
                const response = await fetch(`${API_BASE}/api/queue`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ scene_id: sceneId, duration, transition })
                });
                if (response.ok) {
                    await loadQueue();
                }
            } catch (error) {
                console.error('Failed to add to queue:', error);
            }
        }

        // File management
        async function loadFiles() {
            try {
                const response = await fetch(`${API_BASE}/api/files`);
                if (response.ok) {
                    const data = await response.json();
                    renderFiles(data.files || []);
                }
            } catch (error) {
                console.error('Failed to load files:', error);
            }
        }

        function renderFiles(files) {
            const grid = document.getElementById('filesList');
            if (!grid) return;
            grid.innerHTML = '';
            
            if (files.length === 0) {
                grid.innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: var(--spacing-lg); grid-column: 1 / -1;">No files uploaded</div>';
                    return;
                }
                
            files.forEach(file => {
                const item = document.createElement('div');
                item.className = 'file-item draggable';
                item.draggable = true;
                item.dataset.fileId = file.id;
                item.dataset.dragData = JSON.stringify({ type: 'file', fileId: file.id, fileName: file.file_path.split('/').pop() });
                item.innerHTML = `
                    <div style="font-size: 10px; padding: var(--spacing-sm); text-align: center;">
                        ${file.file_path.split('/').pop()}
                        <div style="font-size: 9px; color: var(--text-muted); margin-top: 4px;">
                            ${file.file_type}
                            </div>
                        </div>
                    `;
                item.addEventListener('dragstart', handleDragStart);
                item.addEventListener('dragend', handleDragEnd);
                item.addEventListener('click', () => {
                    if (confirm('Delete this file?')) {
                        deleteFile(file.id);
                    }
                });
                grid.appendChild(item);
            });
        }

        async function deleteFile(fileId) {
            try {
                const response = await fetch(`${API_BASE}/api/files/${fileId}`, { method: 'DELETE' });
                if (response.ok) {
                    await loadFiles();
                }
            } catch (error) {
                console.error('Failed to delete file:', error);
            }
        }

        // Lower third creation
        async function createLowerThird() {
            const line1 = document.getElementById('lowerThirdLine1').value;
            const line2 = document.getElementById('lowerThirdLine2').value;
            if (!line1) return;
            
            try {
                const response = await fetch(`${API_BASE}/api/graphics/lower_third`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        source_id: `lower_third_${Date.now()}`,
                        line1,
                        line2
                    })
                });
                if (response.ok) {
                    alert('Lower third created');
                }
            } catch (error) {
                console.error('Failed to create lower third:', error);
            }
        }

        // Status polling
        function startStatusPolling() {
            setInterval(checkMixerStatus, 2000);
            setInterval(updateAudioLevels, 100);
        }

        function updateAudioLevels() {
            // Simulate audio levels
            for (let i = 0; i < 4; i++) {
                const level = document.getElementById(`audio-${i}-level`);
                if (level) {
                    const height = Math.random() * 80;
                    level.style.height = `${height}%`;
                }
            }
        }

        // Toast notification system
        function showToast(message, type = 'info', duration = 5000) {
            const container = document.getElementById('toastContainer');
            if (!container) return;
            
            const icons = {
                error: '‚ö†Ô∏è',
                success: '‚úì',
                warning: '‚ö°',
                info: '‚ÑπÔ∏è'
            };
            
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.innerHTML = `
                <span class="toast-icon">${icons[type] || icons.info}</span>
                <span class="toast-message">${message}</span>
                <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
            `;
            
            container.appendChild(toast);
            
            // Auto-remove after duration
            if (duration > 0) {
                setTimeout(() => {
                    toast.classList.add('toast-exit');
                    setTimeout(() => toast.remove(), 200);
                }, duration);
            }
            
            return toast;
        }
        
        function showError(message) {
            console.error(message);
            showToast(message, 'error');
        }
        
        function showSuccess(message) {
            console.log(message);
            showToast(message, 'success', 3000);
        }
        
        function showWarning(message) {
            console.warn(message);
            showToast(message, 'warning', 4000);
        }

        // Scene Editor Functions
        function selectBox(boxNumber) {
            selectedBox = boxNumber;
            document.querySelectorAll('.box-selector-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[data-box="${boxNumber}"]`)?.classList.add('active');
        }

        function assignInput(inputId) {
            boxMappings[selectedBox] = inputId === 'none' ? null : inputId;
            document.querySelectorAll('.input-selector-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[data-input="${inputId}"]`)?.classList.add('active');
        }

        function switchPresetTab(tab) {
            document.querySelectorAll('.preset-tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`[data-tab="${tab}"]`)?.classList.add('active');
            loadPresets(tab);
        }

        async function loadPresets(type) {
            const grid = document.getElementById('presetGrid');
            if (!grid) return;
            grid.innerHTML = '';
            
            // Load preset scenes based on type
            const presetScenes = {
                presets: ['quad', 'two_up', 'cam0_full', 'cam1_full'],
                art: [],
                copy: []
            };
            
            const scenesToShow = presetScenes[type] || [];
            scenesToShow.forEach(sceneId => {
                const scene = scenes.find(s => s.id === sceneId);
                if (scene) {
                    const thumb = document.createElement('div');
                    thumb.className = 'preset-thumbnail';
                    thumb.innerHTML = `<div class="preset-thumbnail-label">${scene.label || scene.id}</div>`;
                    thumb.addEventListener('click', () => {
                        applyToPreview(sceneId);
                        closePanel();
                    });
                    grid.appendChild(thumb);
                }
            });
        }

        async function saveScene() {
            if (!editingScene) return;
                try {
                const response = await fetch(`${API_BASE}/api/scenes`, {
                    method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(editingScene)
                    });
                    if (response.ok) {
                    await loadScenes();
                    editingScene = null;
                    document.getElementById('saveSceneBtn').style.display = 'none';
                    document.getElementById('cancelSceneBtn').style.display = 'none';
                    }
                } catch (error) {
                console.error('Failed to save scene:', error);
                }
        }

        // Audio functions
        function toggleMute(channel) {
            const btn = document.getElementById(`audio-mute-${channel}`);
            btn.classList.toggle('active');
        }

        function toggleSolo(channel) {
            const btn = document.getElementById(`audio-solo-${channel}`);
            btn.classList.toggle('active');
        }

        // Graphics templates
        async function loadGraphicsTemplates() {
            try {
                const response = await fetch(`${API_BASE}/api/graphics/templates?template_type=lower_third`);
                    if (response.ok) {
                        const data = await response.json();
                    renderGraphicsTemplates(data.templates || []);
                }
            } catch (error) {
                console.error('Failed to load graphics templates:', error);
            }
        }

        function renderGraphicsTemplates(templates) {
            const grid = document.getElementById('graphicsTemplates');
            if (!grid) return;
            grid.innerHTML = '';
            
            templates.forEach(template => {
                const item = document.createElement('div');
                item.className = 'template-item';
                item.innerHTML = `<div style="padding: var(--spacing-sm); font-size: 10px; text-align: center;">${template.name}</div>`;
                item.addEventListener('click', () => {
                    // Apply template
                    console.log('Apply template:', template.id);
                });
                grid.appendChild(item);
            });
        }

        // Make functions globally accessible
        window.removeFromQueue = removeFromQueue;
        window.selectBox = selectBox;
        window.assignInput = assignInput;
        window.switchPresetTab = switchPresetTab;
        window.toggleMute = toggleMute;
        window.toggleSolo = toggleSolo;

        // Initialize on load
        window.addEventListener('load', init);
        
        // Cleanup on unload
        window.addEventListener('beforeunload', () => {
            Object.values(hlsInstances).forEach(hls => {
                if (hls && hls.destroy) hls.destroy();
            });
        });
    </script>
</body>
</html>
