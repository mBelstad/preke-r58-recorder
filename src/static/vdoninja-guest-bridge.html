<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VDO.ninja Guest Bridge - HDMI Camera</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            min-height: 100vh;
            color: #e2e8f0;
            padding: 20px;
        }
        .container { max-width: 1000px; margin: 0 auto; }
        h1 { 
            text-align: center; 
            color: #22d3ee; 
            margin-bottom: 8px;
            font-size: 1.8rem;
        }
        .subtitle { 
            text-align: center; 
            color: #64748b; 
            margin-bottom: 30px;
            font-size: 0.9rem;
        }
        .card {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .card h2 {
            color: #22d3ee;
            font-size: 1.1rem;
            margin-bottom: 16px;
            font-weight: 500;
        }
        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-bottom: 16px;
        }
        .form-group { margin-bottom: 16px; }
        label {
            display: block;
            color: #94a3b8;
            font-size: 0.85rem;
            margin-bottom: 6px;
        }
        input, select {
            width: 100%;
            padding: 12px 14px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            background: rgba(0,0,0,0.3);
            color: #fff;
            font-size: 0.9rem;
        }
        input:focus { outline: none; border-color: #22d3ee; }
        .controls {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }
        button {
            padding: 14px 28px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        .btn-primary { background: #22d3ee; color: #0f172a; }
        .btn-primary:hover { background: #67e8f9; }
        .btn-primary:disabled { background: #475569; color: #94a3b8; cursor: not-allowed; }
        .btn-danger { background: #ef4444; color: white; }
        .btn-danger:hover { background: #dc2626; }
        .btn-secondary { background: rgba(255,255,255,0.1); color: #fff; }
        .btn-secondary:hover { background: rgba(255,255,255,0.2); }
        
        .status-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }
        .status-item {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
        }
        .status-item .label { 
            font-size: 0.75rem; 
            color: #64748b; 
            margin-bottom: 4px;
            text-transform: uppercase;
        }
        .status-item .value { 
            font-size: 1rem; 
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #64748b;
        }
        .status-dot.connected { background: #22c55e; }
        .status-dot.connecting { background: #f59e0b; animation: pulse 1s infinite; }
        .status-dot.error { background: #ef4444; }
        @keyframes pulse { 50% { opacity: 0.5; } }
        
        .video-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .video-box {
            background: #000;
            border-radius: 12px;
            overflow: hidden;
            aspect-ratio: 16/9;
            position: relative;
        }
        .video-box video {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        .video-label {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 500;
        }
        
        .log {
            background: rgba(0,0,0,0.4);
            border-radius: 8px;
            padding: 12px;
            max-height: 250px;
            overflow-y: auto;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 0.75rem;
            line-height: 1.7;
        }
        .log-entry { margin-bottom: 2px; }
        .log-entry.info { color: #22d3ee; }
        .log-entry.success { color: #22c55e; }
        .log-entry.error { color: #ef4444; }
        .log-entry.warn { color: #f59e0b; }
        
        .info-box {
            background: rgba(34, 211, 238, 0.1);
            border: 1px solid rgba(34, 211, 238, 0.3);
            border-radius: 8px;
            padding: 14px;
            margin-bottom: 20px;
            font-size: 0.85rem;
            line-height: 1.6;
        }
        .info-box strong { color: #22d3ee; }
        
        .links-box {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 14px;
            margin-top: 16px;
        }
        .links-box a {
            color: #22d3ee;
            text-decoration: none;
            display: block;
            margin: 6px 0;
            word-break: break-all;
            font-size: 0.85rem;
        }
        .links-box a:hover { text-decoration: underline; }

        @media (max-width: 768px) {
            .form-row, .video-container, .status-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé• VDO.ninja Guest Bridge</h1>
        <p class="subtitle">Bridges HDMI cameras from MediaMTX into VDO.ninja rooms as guests</p>
        
        <div class="info-box">
            <strong>How it works:</strong> This page pulls video from your HDMI camera via WHEP, 
            then joins a VDO.ninja room as a guest using WebRTC. The camera appears as a normal 
            participant that can be assigned to layout elements.
        </div>
        
        <div class="card">
            <h2>üì° Configuration</h2>
            <div class="form-row">
                <div class="form-group">
                    <label>Camera WHEP URL</label>
                    <input type="text" id="whepUrl" value="https://r58-api.itagenten.no/whep/cam2" 
                           placeholder="https://server/whep/camera">
                </div>
                <div class="form-group">
                    <label>Guest Name (Stream ID)</label>
                    <input type="text" id="guestName" value="HDMI-Cam2" placeholder="My-Camera">
                </div>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label>VDO.ninja Room</label>
                    <input type="text" id="roomName" value="r58studio" placeholder="roomname">
                </div>
                <div class="form-group">
                    <label>VDO.ninja Host</label>
                    <input type="text" id="vdoHost" value="r58-vdo.itagenten.no" placeholder="vdo.ninja">
                </div>
            </div>
            <div class="controls">
                <button class="btn-primary" id="startBtn" onclick="startBridge()">‚ñ∂ Start Bridge</button>
                <button class="btn-danger" id="stopBtn" onclick="stopBridge()" disabled>‚ñ† Stop</button>
                <button class="btn-secondary" onclick="openDirector()">Open Director</button>
                <button class="btn-secondary" onclick="openMixer()">Open Mixer</button>
            </div>
        </div>
        
        <div class="card">
            <h2>üìä Status</h2>
            <div class="status-grid">
                <div class="status-item">
                    <div class="label">WHEP Source</div>
                    <div class="value">
                        <span class="status-dot" id="whepDot"></span>
                        <span id="whepStatus">Disconnected</span>
                    </div>
                </div>
                <div class="status-item">
                    <div class="label">VDO.ninja Room</div>
                    <div class="value">
                        <span class="status-dot" id="roomDot"></span>
                        <span id="roomStatus">Not joined</span>
                    </div>
                </div>
                <div class="status-item">
                    <div class="label">Publishing</div>
                    <div class="value">
                        <span class="status-dot" id="pubDot"></span>
                        <span id="pubStatus">Not publishing</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="card">
            <h2>üñ• Video Preview</h2>
            <div class="video-container">
                <div class="video-box">
                    <span class="video-label">üìπ WHEP Input (Camera)</span>
                    <video id="inputVideo" autoplay muted playsinline></video>
                </div>
                <div class="video-box">
                    <span class="video-label">üåê VDO.ninja Output</span>
                    <video id="outputVideo" autoplay muted playsinline></video>
                </div>
            </div>
            
            <div class="links-box" id="linksBox" style="display: none;">
                <strong>Room Links:</strong>
                <a href="#" id="directorLink" target="_blank">üé¨ Director Room</a>
                <a href="#" id="sceneLink" target="_blank">üì∫ Scene View (for OBS)</a>
                <a href="#" id="guestLink" target="_blank">üë§ Guest Invite Link</a>
            </div>
        </div>
        
        <div class="card">
            <h2>üìã Activity Log</h2>
            <div class="log" id="log"></div>
        </div>
    </div>
    
    <!-- VDO.ninja API Script -->
    <script>
        // State
        let whepPC = null;
        let mediaStream = null;
        let vdoSession = null;
        let wsConnection = null;
        
        function log(message, type = 'info') {
            const logEl = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logEl.insertBefore(entry, logEl.firstChild);
            console.log(`[${type.toUpperCase()}] ${message}`);
        }
        
        function updateStatus(element, dot, status, isActive) {
            document.getElementById(element).textContent = status;
            const dotEl = document.getElementById(dot);
            dotEl.className = 'status-dot';
            if (isActive === true) dotEl.classList.add('connected');
            else if (isActive === 'connecting') dotEl.classList.add('connecting');
            else if (isActive === false) dotEl.classList.add('error');
        }
        
        // Connect to WHEP source (MediaMTX camera)
        async function connectWhep(whepUrl) {
            log(`Connecting to WHEP: ${whepUrl}`);
            updateStatus('whepStatus', 'whepDot', 'Connecting...', 'connecting');
            
            try {
                whepPC = new RTCPeerConnection({
                    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                });
                
                whepPC.addTransceiver('video', { direction: 'recvonly' });
                whepPC.addTransceiver('audio', { direction: 'recvonly' });
                
                const streamPromise = new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => reject(new Error('Timeout waiting for tracks')), 15000);
                    
                    whepPC.ontrack = (event) => {
                        log(`Received ${event.track.kind} track`, 'success');
                        if (!mediaStream) {
                            mediaStream = event.streams[0];
                            document.getElementById('inputVideo').srcObject = mediaStream;
                        }
                        if (mediaStream.getTracks().length >= 2 || event.track.kind === 'video') {
                            clearTimeout(timeout);
                            resolve(mediaStream);
                        }
                    };
                });
                
                whepPC.oniceconnectionstatechange = () => {
                    log(`WHEP ICE: ${whepPC.iceConnectionState}`);
                    if (whepPC.iceConnectionState === 'failed') {
                        updateStatus('whepStatus', 'whepDot', 'ICE Failed', false);
                    }
                };
                
                const offer = await whepPC.createOffer();
                await whepPC.setLocalDescription(offer);
                
                // Wait for ICE gathering
                await new Promise((resolve) => {
                    if (whepPC.iceGatheringState === 'complete') resolve();
                    else {
                        const checkState = () => {
                            if (whepPC.iceGatheringState === 'complete') resolve();
                        };
                        whepPC.onicegatheringstatechange = checkState;
                        setTimeout(resolve, 3000);
                    }
                });
                
                log('WHEP: Sending offer to server');
                
                const response = await fetch(whepUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/sdp' },
                    body: whepPC.localDescription.sdp
                });
                
                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(`WHEP ${response.status}: ${text.substring(0, 100)}`);
                }
                
                const answerSdp = await response.text();
                await whepPC.setRemoteDescription({ type: 'answer', sdp: answerSdp });
                
                await streamPromise;
                updateStatus('whepStatus', 'whepDot', 'Connected', true);
                log('WHEP: Stream connected!', 'success');
                return mediaStream;
                
            } catch (error) {
                log(`WHEP error: ${error.message}`, 'error');
                updateStatus('whepStatus', 'whepDot', 'Failed', false);
                throw error;
            }
        }
        
        // Join VDO.ninja room and publish stream
        async function joinVdoRoom(stream, roomName, guestName, vdoHost) {
            log(`Joining VDO.ninja room: ${roomName} as ${guestName}`);
            updateStatus('roomStatus', 'roomDot', 'Connecting...', 'connecting');
            
            try {
                // Generate a unique push ID
                const pushId = guestName.toLowerCase().replace(/[^a-z0-9]/g, '') + Math.random().toString(36).substring(2, 6);
                
                // Build the VDO.ninja WebSocket URL
                // VDO.ninja uses wss://wss.vdo.ninja for signaling
                const wsHost = vdoHost.includes('vdo.ninja') ? 'wss.vdo.ninja' : vdoHost.replace('https://', 'wss://').replace('http://', 'ws://');
                
                // For now, we'll use an iframe approach that's more reliable
                // Create a hidden iframe that loads VDO.ninja with the stream
                
                // Actually, VDO.ninja's internal API is complex. 
                // The easiest approach is to capture the canvas/video and use the standard guest join flow.
                
                // Let's use a simpler approach: Create a canvas that mirrors the video,
                // then use canvas.captureStream() to create a new MediaStream that we can send.
                
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const video = document.getElementById('inputVideo');
                
                // Wait for video to have dimensions
                await new Promise(resolve => {
                    if (video.videoWidth > 0) resolve();
                    else video.onloadedmetadata = resolve;
                    setTimeout(resolve, 3000);
                });
                
                canvas.width = video.videoWidth || 1920;
                canvas.height = video.videoHeight || 1080;
                
                // Draw video to canvas continuously
                function drawFrame() {
                    if (video.readyState >= 2) {
                        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    }
                    requestAnimationFrame(drawFrame);
                }
                drawFrame();
                
                // Create stream from canvas
                const canvasStream = canvas.captureStream(30);
                
                // Add audio track from original stream if available
                const audioTracks = stream.getAudioTracks();
                if (audioTracks.length > 0) {
                    canvasStream.addTrack(audioTracks[0]);
                }
                
                log(`Canvas stream created: ${canvas.width}x${canvas.height}`, 'info');
                
                // Show in output preview
                document.getElementById('outputVideo').srcObject = canvasStream;
                
                // Now we need to publish this to VDO.ninja
                // VDO.ninja uses a WebSocket for signaling
                // The simplest way is to use the &push= parameter with an iframe
                
                // Create an invisible VDO.ninja guest iframe
                // We'll use postMessage to send the stream, but VDO.ninja doesn't support this directly
                
                // Alternative: Use VDO.ninja's API endpoint
                // Actually, let's try using the VDO.ninja IFrame API
                
                // For the most reliable approach, we'll create an actual peer connection
                // to VDO.ninja's signaling server
                
                const vdoUrl = `https://${vdoHost}/?push=${pushId}&room=${roomName}&label=${encodeURIComponent(guestName)}&autostart&videodevice=0&audiodevice=0&webcam`;
                
                log(`VDO.ninja URL: ${vdoUrl}`, 'info');
                
                // Unfortunately, we can't easily inject a MediaStream into VDO.ninja's iframe
                // The most reliable approach is to use screen capture + virtual camera
                // or to run this in Electron with virtual camera support
                
                // For now, let's show the user what to do:
                updateStatus('roomStatus', 'roomDot', 'Manual Required', 'connecting');
                updateStatus('pubStatus', 'pubDot', 'See Instructions', 'connecting');
                
                log('=== MANUAL STEPS REQUIRED ===', 'warn');
                log('1. Open the VDO.ninja guest link below', 'warn');
                log('2. Select "Share Screen" instead of camera', 'warn');
                log('3. Choose "Chrome Tab" and select THIS tab', 'warn');
                log('The HDMI camera will then appear in the room!', 'warn');
                
                // Show links
                showLinks(roomName, pushId, vdoHost);
                
                // Open VDO.ninja guest page in new tab
                const guestUrl = `https://${vdoHost}/?push=${pushId}&room=${roomName}&label=${encodeURIComponent(guestName)}&screenshare&autostart`;
                log(`Guest URL (screen share): ${guestUrl}`, 'info');
                
                return { pushId, guestUrl };
                
            } catch (error) {
                log(`VDO.ninja error: ${error.message}`, 'error');
                updateStatus('roomStatus', 'roomDot', 'Failed', false);
                throw error;
            }
        }
        
        function showLinks(roomName, pushId, vdoHost) {
            document.getElementById('directorLink').href = `https://${vdoHost}/?director=${roomName}`;
            document.getElementById('directorLink').textContent = `üé¨ Director: https://${vdoHost}/?director=${roomName}`;
            
            document.getElementById('sceneLink').href = `https://${vdoHost}/?scene&room=${roomName}`;
            document.getElementById('sceneLink').textContent = `üì∫ Scene: https://${vdoHost}/?scene&room=${roomName}`;
            
            document.getElementById('guestLink').href = `https://${vdoHost}/?room=${roomName}`;
            document.getElementById('guestLink').textContent = `üë§ Guest Invite: https://${vdoHost}/?room=${roomName}`;
            
            document.getElementById('linksBox').style.display = 'block';
        }
        
        async function startBridge() {
            const whepUrl = document.getElementById('whepUrl').value;
            const guestName = document.getElementById('guestName').value;
            const roomName = document.getElementById('roomName').value;
            const vdoHost = document.getElementById('vdoHost').value;
            
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            
            try {
                // Step 1: Connect to WHEP source
                const stream = await connectWhep(whepUrl);
                
                // Step 2: Join VDO.ninja room
                await joinVdoRoom(stream, roomName, guestName, vdoHost);
                
                log('Bridge setup complete!', 'success');
                
            } catch (error) {
                log(`Bridge failed: ${error.message}`, 'error');
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
            }
        }
        
        function stopBridge() {
            log('Stopping bridge...');
            
            if (whepPC) {
                whepPC.close();
                whepPC = null;
            }
            
            mediaStream = null;
            
            document.getElementById('inputVideo').srcObject = null;
            document.getElementById('outputVideo').srcObject = null;
            document.getElementById('linksBox').style.display = 'none';
            
            updateStatus('whepStatus', 'whepDot', 'Disconnected', null);
            updateStatus('roomStatus', 'roomDot', 'Not joined', null);
            updateStatus('pubStatus', 'pubDot', 'Not publishing', null);
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            
            log('Bridge stopped', 'info');
        }
        
        function openDirector() {
            const roomName = document.getElementById('roomName').value;
            const vdoHost = document.getElementById('vdoHost').value;
            window.open(`https://${vdoHost}/?director=${roomName}`, '_blank');
        }
        
        function openMixer() {
            const roomName = document.getElementById('roomName').value;
            const vdoHost = document.getElementById('vdoHost').value;
            window.open(`https://${vdoHost}/mixer.html?room=${roomName}`, '_blank');
        }
        
        // Parse URL params
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('whep')) document.getElementById('whepUrl').value = urlParams.get('whep');
        if (urlParams.get('name') || urlParams.get('guest')) document.getElementById('guestName').value = urlParams.get('name') || urlParams.get('guest');
        if (urlParams.get('room')) document.getElementById('roomName').value = urlParams.get('room');
        if (urlParams.get('host') || urlParams.get('vdo')) document.getElementById('vdoHost').value = urlParams.get('host') || urlParams.get('vdo');
        if (urlParams.get('autostart')) {
            window.addEventListener('load', () => setTimeout(startBridge, 1000));
        }
    </script>
</body>
</html>

