import{C as D,r as n,h as p,i as v}from"./index-BbwUNoU5.js";const A=D("recorder",()=>{const s=n("idle"),i=n(null),d=n(null),l=n(0),g=n(0),h=n(!1),o=n([]),_=p(()=>s.value==="recording"),R=p(()=>{const e=Math.floor(l.value/1e3),t=Math.floor(e/3600),r=Math.floor(e%3600/60),a=e%60;return`${t.toString().padStart(2,"0")}:${r.toString().padStart(2,"0")}:${a.toString().padStart(2,"0")}`}),m=p(()=>o.value.filter(e=>e.hasSignal)),f=n(null);async function w(e){s.value="starting",f.value=null;try{const t=await v.startRecording({name:e,inputs:m.value.map(r=>r.id)});i.value=t.session_id,d.value={id:t.session_id,name:e||null,startedAt:new Date(t.started_at),duration:0,inputs:o.value.filter(r=>r.hasSignal)},o.value.forEach(r=>{r.hasSignal&&(r.isRecording=!0)}),s.value="recording",S(),console.log(`[Recorder] Started recording: ${t.session_id}`)}catch(t){throw console.error("Failed to start recording:",t),f.value=t.message||"Failed to start recording",s.value="idle",t}}async function y(){s.value="stopping",f.value=null;try{const e=await v.stopRecording(i.value||void 0);return console.log(`[Recorder] Stopped recording: ${e.session_id}, duration: ${e.duration_ms}ms`),o.value.forEach(t=>{t.isRecording=!1}),d.value=null,i.value=null,l.value=0,g.value=0,s.value="idle",u&&(clearInterval(u),u=null),{duration_ms:e.duration_ms,files:e.files}}catch(e){throw console.error("Failed to stop recording:",e),f.value=e.message||"Failed to stop recording",s.value="recording",e}}async function I(){try{const e=await v.getRecorderStatus();e.status==="recording"?(s.value="recording",i.value=e.session_id||null,l.value=e.duration_ms,g.value=e.duration_ms,e.inputs.forEach(t=>{const r=o.value.find(a=>a.id===t);r&&(r.isRecording=!0)}),S()):(s.value="idle",i.value=null)}catch(e){console.error("Failed to fetch recorder status:",e)}}async function b(){try{const e=await v.getInputsStatus();o.value=e.map(t=>({id:t.id,label:t.label,hasSignal:t.has_signal,isRecording:t.is_recording,bytesWritten:0,resolution:t.resolution||"",framerate:t.framerate||0})),h.value=!0,console.log(`[Recorder] Loaded ${o.value.length} inputs, ${o.value.filter(t=>t.hasSignal).length} with signal`)}catch(e){console.error("Failed to fetch inputs status:",e)}}let u=null;function S(){u&&clearInterval(u),u=window.setInterval(()=>{d.value&&(l.value=Date.now()-d.value.startedAt.getTime())},100)}function $(e){if(e.duration_ms!==void 0&&(l.value=e.duration_ms,g.value=e.duration_ms),e.session_id&&(i.value=e.session_id),e.bytes_written)for(const[t,r]of Object.entries(e.bytes_written)){const a=o.value.find(c=>c.id===t);a&&(a.bytesWritten=r)}e.inputs&&e.inputs.forEach(t=>{const r=o.value.find(a=>a.id===t.id);r&&Object.assign(r,t)})}function F(e,t,r,a){const c=o.value.find(E=>E.id===e);c&&(c.hasSignal=t,r&&(c.resolution=r),a&&(c.framerate=a))}return{status:s,sessionId:i,currentSession:d,duration:l,durationMs:g,inputs:o,inputsLoaded:h,lastError:f,isRecording:_,formattedDuration:R,activeInputs:m,startRecording:w,stopRecording:y,fetchStatus:I,fetchInputs:b,updateFromEvent:$,updateInputSignal:F}});export{A as u};
